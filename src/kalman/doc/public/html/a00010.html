<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>KFilter: Kalman::EKFilter&lt; T, BEG, OQ, OVR, DBG &gt; Class Template Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.5 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li id="current"><a href="annotated.html"><span>Classes</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li><a href="dirs.html"><span>Directories</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
  </ul></div>
<div class="tabs">
  <ul>
    <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
    <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
    <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
  </ul></div>
<div class="nav">
<a class="el" href="a00029.html">Kalman</a>::<a class="el" href="a00010.html">EKFilter</a></div>
<h1>Kalman::EKFilter&lt; T, BEG, OQ, OVR, DBG &gt; Class Template Reference</h1><!-- doxytag: class="Kalman::EKFilter" -->Generic Extended Kalman Filter (EKF) template base class.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;<a class="el" href="a00032.html">ekfilter.hpp</a>&gt;</code>
<p>
<p>Inheritance diagram for Kalman::EKFilter&lt; T, BEG, OQ, OVR, DBG &gt;:
<p><center><img src="a00010.png" usemap="#Kalman::EKFilter< T, BEG, OQ, OVR, DBG >_map" border="0" alt=""></center>
<map name="Kalman::EKFilter< T, BEG, OQ, OVR, DBG >_map">
<area href="a00012.html" alt="Kalman::KFilter< T, BEG, OQ, OVR, DBG >" shape="rect" coords="0,56,269,80">
</map>
Collaboration diagram for Kalman::EKFilter&lt; T, BEG, OQ, OVR, DBG &gt;:<p><center><img src="a00062.png" border="0" usemap="#a00063" alt="Collaboration graph"></center>
<map name="a00063">
<area href="a00015.html" shape="rect" coords="7,18,215,42" alt="">
<area href="a00013.html" shape="rect" coords="238,18,446,42" alt="">
</map>
<center><font size="2">[<a href="graph_legend.html">legend</a>]</font></center><a href="a00001.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Types</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="599dcce2998a6b40b1e38e8c6006cb0a"></a><!-- doxytag: member="Kalman::EKFilter::type" ref="599dcce2998a6b40b1e38e8c6006cb0a" args="" -->
typedef T&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00010.html#599dcce2998a6b40b1e38e8c6006cb0a">type</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Type of objects contained in matrices and vectors. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="57dea6f5039281b7fee517fc43bf3110"></a><!-- doxytag: member="Kalman::EKFilter::Vector" ref="57dea6f5039281b7fee517fc43bf3110" args="" -->
typedef <a class="el" href="a00015.html">KVector</a>&lt; T, BEG, DBG &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00010.html#57dea6f5039281b7fee517fc43bf3110">Vector</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Vector type. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="f53df0293e169f562bc1d9a20e1d2589"></a><!-- doxytag: member="Kalman::EKFilter::Matrix" ref="f53df0293e169f562bc1d9a20e1d2589" args="" -->
typedef <a class="el" href="a00013.html">KMatrix</a>&lt; T, BEG, DBG &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00010.html#f53df0293e169f562bc1d9a20e1d2589">Matrix</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Matrix type. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom">{ <a class="el" href="a00010.html#dca29a1140aadadfd92b34a02fa516ef63a08f52a29e0f7a1f987f4495164ab0">beg</a> =  BEG
 }</td></tr>

<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00010.html#50886bc1066141f71bd94296cd8ad676">init</a> (<a class="el" href="a00015.html">Vector</a> &amp;x_, <a class="el" href="a00013.html">Matrix</a> &amp;P_)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets initial conditions for the Kalman Filter.  <a href="#50886bc1066141f71bd94296cd8ad676"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Constructor and Destructor.</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="2b49f9dfe135085516183ca600564ecd"></a><!-- doxytag: member="Kalman::EKFilter::EKFilter" ref="2b49f9dfe135085516183ca600564ecd" args="()" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00010.html#2b49f9dfe135085516183ca600564ecd">EKFilter</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Default constructor. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00010.html#4f5276a8a88934d273fb4f761ab01b95">EKFilter</a> (<a class="el" href="a00029.html#52dcd207f3e190d4f374ce16bdcd153f">K_UINT_32</a> n_, <a class="el" href="a00029.html#52dcd207f3e190d4f374ce16bdcd153f">K_UINT_32</a> nu_, <a class="el" href="a00029.html#52dcd207f3e190d4f374ce16bdcd153f">K_UINT_32</a> nw_, <a class="el" href="a00029.html#52dcd207f3e190d4f374ce16bdcd153f">K_UINT_32</a> m_, <a class="el" href="a00029.html#52dcd207f3e190d4f374ce16bdcd153f">K_UINT_32</a> nv_)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructors specifying all necessary matrix and vector dimensions.  <a href="#4f5276a8a88934d273fb4f761ab01b95"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="4e1d6a23da39e7dc8e689b980006cdce"></a><!-- doxytag: member="Kalman::EKFilter::~EKFilter" ref="4e1d6a23da39e7dc8e689b980006cdce" args="()" -->
virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00010.html#4e1d6a23da39e7dc8e689b980006cdce">~EKFilter</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Virtual destructor. <br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Dimension Accessor Functions</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ed9480862d6cb9be0264c0aad8862926"></a><!-- doxytag: member="Kalman::EKFilter::getSizeX" ref="ed9480862d6cb9be0264c0aad8862926" args="() const " -->
<a class="el" href="a00029.html#52dcd207f3e190d4f374ce16bdcd153f">K_UINT_32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00010.html#ed9480862d6cb9be0264c0aad8862926">getSizeX</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the size of the state vector. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="c3b4e51482d1215ec0ad65346e0f33c2"></a><!-- doxytag: member="Kalman::EKFilter::getSizeU" ref="c3b4e51482d1215ec0ad65346e0f33c2" args="() const " -->
<a class="el" href="a00029.html#52dcd207f3e190d4f374ce16bdcd153f">K_UINT_32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00010.html#c3b4e51482d1215ec0ad65346e0f33c2">getSizeU</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the size of the input vector. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a37b16daac459e871fe3c477f90b72af"></a><!-- doxytag: member="Kalman::EKFilter::getSizeW" ref="a37b16daac459e871fe3c477f90b72af" args="() const " -->
<a class="el" href="a00029.html#52dcd207f3e190d4f374ce16bdcd153f">K_UINT_32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00010.html#a37b16daac459e871fe3c477f90b72af">getSizeW</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the size of the process noise vector. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="e986404794059dfb8cd93289ca5ba499"></a><!-- doxytag: member="Kalman::EKFilter::getSizeZ" ref="e986404794059dfb8cd93289ca5ba499" args="() const " -->
<a class="el" href="a00029.html#52dcd207f3e190d4f374ce16bdcd153f">K_UINT_32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00010.html#e986404794059dfb8cd93289ca5ba499">getSizeZ</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the size of the measurement vector. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="5598ed90355e06a068e4fa6aa944243c"></a><!-- doxytag: member="Kalman::EKFilter::getSizeV" ref="5598ed90355e06a068e4fa6aa944243c" args="() const " -->
<a class="el" href="a00029.html#52dcd207f3e190d4f374ce16bdcd153f">K_UINT_32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00010.html#5598ed90355e06a068e4fa6aa944243c">getSizeV</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the size of the measurement noise vector. <br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Resizing Functions</div></td></tr>
<tr><td colspan="2"><div class="groupText">These functions allow to change the dimensions of all matrices and vectors, thus implementing a Variable-Dimension Extended Kalman Filter. They do nothing if the new size is the same as the old one. <dl compact><dt><b>Warning:</b></dt><dd><code>setDim()</code> (or the five <code>setSize</code> functions) <b>must</b> be called <b>before</b> any other function, or else, matrices and vectors will not have their memory allocated. </dd></dl>
<br><br></div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00010.html#23101e8b17b27d57b1bf2668904bf4ec">setDim</a> (<a class="el" href="a00029.html#52dcd207f3e190d4f374ce16bdcd153f">K_UINT_32</a> n_, <a class="el" href="a00029.html#52dcd207f3e190d4f374ce16bdcd153f">K_UINT_32</a> nu_, <a class="el" href="a00029.html#52dcd207f3e190d4f374ce16bdcd153f">K_UINT_32</a> nw_, <a class="el" href="a00029.html#52dcd207f3e190d4f374ce16bdcd153f">K_UINT_32</a> m_, <a class="el" href="a00029.html#52dcd207f3e190d4f374ce16bdcd153f">K_UINT_32</a> nv_)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets all dimensions at once.  <a href="#23101e8b17b27d57b1bf2668904bf4ec"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00010.html#5d3999b77ab3165b6c2b0b8b8f192139">setSizeX</a> (<a class="el" href="a00029.html#52dcd207f3e190d4f374ce16bdcd153f">K_UINT_32</a> n_)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the size of the state vector.  <a href="#5d3999b77ab3165b6c2b0b8b8f192139"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="5fadf1a13e6030168d073ef4fa7d162f"></a><!-- doxytag: member="Kalman::EKFilter::setSizeU" ref="5fadf1a13e6030168d073ef4fa7d162f" args="(K_UINT_32 nu_)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00010.html#5fadf1a13e6030168d073ef4fa7d162f">setSizeU</a> (<a class="el" href="a00029.html#52dcd207f3e190d4f374ce16bdcd153f">K_UINT_32</a> nu_)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the size of the input vector. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00010.html#ef9e77d7e4d0e9c963456455ba5b85cc">setSizeW</a> (<a class="el" href="a00029.html#52dcd207f3e190d4f374ce16bdcd153f">K_UINT_32</a> nw_)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the size of the process noise vector.  <a href="#ef9e77d7e4d0e9c963456455ba5b85cc"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ef7c6328d66fc66f3f43b5bb24c67ff5"></a><!-- doxytag: member="Kalman::EKFilter::setSizeZ" ref="ef7c6328d66fc66f3f43b5bb24c67ff5" args="(K_UINT_32 m_)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00010.html#ef7c6328d66fc66f3f43b5bb24c67ff5">setSizeZ</a> (<a class="el" href="a00029.html#52dcd207f3e190d4f374ce16bdcd153f">K_UINT_32</a> m_)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the size of the measurement vector. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="3fd4fa1f9458c5221eabdd23880bce45"></a><!-- doxytag: member="Kalman::EKFilter::setSizeV" ref="3fd4fa1f9458c5221eabdd23880bce45" args="(K_UINT_32 nv_)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00010.html#3fd4fa1f9458c5221eabdd23880bce45">setSizeV</a> (<a class="el" href="a00029.html#52dcd207f3e190d4f374ce16bdcd153f">K_UINT_32</a> nv_)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the size of the measurement noise vector. <br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Kalman Filter Functions</div></td></tr>
<tr><td colspan="2"><div class="groupText">These functions allow to get the results from the Kalman filtering algorithm. Before any of these can be called, all dimensions must have been set properly at least once and <code>init()</code> must have been called, also at least once. Each time the user want to resize some vectors, the corresponding resizing functions must be called again before being able to call one of the functions in this section. <code>init()</code> must also be called again if <em>n</em> or <em>nw</em> has changed. <code>init()</code> can also be called solely to reset the filter. <br><br></div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00010.html#9ce43496cd9547c192ba45ffd3e93d13">step</a> (<a class="el" href="a00015.html">Vector</a> &amp;u_, const <a class="el" href="a00015.html">Vector</a> &amp;z_)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Makes one prediction-correction step.  <a href="#9ce43496cd9547c192ba45ffd3e93d13"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00010.html#fd603471b0a9b0c188fc5ac00b993752">timeUpdateStep</a> (<a class="el" href="a00015.html">Vector</a> &amp;u_)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Makes one prediction step.  <a href="#fd603471b0a9b0c188fc5ac00b993752"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00010.html#68983cf3280fc4b7e99ffda7b76bb684">measureUpdateStep</a> (const <a class="el" href="a00015.html">Vector</a> &amp;z_)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Makes one correction step.  <a href="#68983cf3280fc4b7e99ffda7b76bb684"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const <a class="el" href="a00015.html">Vector</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00010.html#fc92e7081f91b62523576c1b3536e4b3">predict</a> (<a class="el" href="a00015.html">Vector</a> &amp;u_)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the predicted state vector (<em>a priori</em> state estimate).  <a href="#fc92e7081f91b62523576c1b3536e4b3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const <a class="el" href="a00015.html">Vector</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00010.html#8e2a9f50c3301dc17bd68c58396369a5">simulate</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the predicted measurement vector.  <a href="#8e2a9f50c3301dc17bd68c58396369a5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="13d45fb54591fd367613a88b03e33dd2"></a><!-- doxytag: member="Kalman::EKFilter::getX" ref="13d45fb54591fd367613a88b03e33dd2" args="() const " -->
const <a class="el" href="a00015.html">Vector</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00010.html#13d45fb54591fd367613a88b03e33dd2">getX</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the corrected state (<em>a posteriori</em> state estimate). <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const <a class="el" href="a00013.html">Matrix</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00010.html#ac0985755b9fbeb6330aef0c34546a91">calculateP</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the <em>a posteriori</em> error covariance estimate matrix.  <a href="#ac0985755b9fbeb6330aef0c34546a91"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00010.html#bfca7d629f94d7954e48597108e0ba21">NoModification</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allows optimizations on some calculations.  <a href="#bfca7d629f94d7954e48597108e0ba21"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="0765f1dd9e4db119c8e1c8baf348954f"></a><!-- doxytag: member="Kalman::EKFilter::sizeUpdate" ref="0765f1dd9e4db119c8e1c8baf348954f" args="()" -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00010.html#0765f1dd9e4db119c8e1c8baf348954f">sizeUpdate</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Resizes all vector and matrices. <b>Never</b> call or overload this ! <br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Matrix Pre-Creators</div></td></tr>
<tr><td colspan="2"><div class="groupText">Theses functions have been designed to be overridden by derived classes if necessary. Their role is to fill in the parts of the Kalman matrices that don't change between iterations. That is to say, these functions should only set constant values inside matrices that don't depend on <em>x</em> or <em>u</em>.<p>
They will all be called at least once, before the calls to their corresponding matrix (not pre-) creators. In fact, they are called once per resize (not necessarily at the moment of the resize though), including while the matrices are first allocated.<p>
<dl compact><dt><b>Note:</b></dt><dd>Matrices have already been properly resized before these functions are called, so no further resizing is or should be necessary. <p>
If a matrix pre-creator is overridden, but it does not modify in any way the matrix in certain execution paths, then the function <code>NoModification()</code> should be called in each of those execution paths so that the filter can optimize away some calculations. The default versions of the matrix pre-creators only call <code>NoModification()</code> in their bodies. </dd></dl>
<dl compact><dt><b>Warning:</b></dt><dd>Each matrix pre-creator cannot suppose that any other matrix pre-creator will be called before or after it. </dd></dl>
<br><br></div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="518036f135c91caa3c3d76b172775485"></a><!-- doxytag: member="Kalman::EKFilter::makeBaseA" ref="518036f135c91caa3c3d76b172775485" args="()" -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00010.html#518036f135c91caa3c3d76b172775485">makeBaseA</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Virtual pre-creator of <em>A</em>. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="fee4e2d5e2ee0e0b384328ef4b5acd10"></a><!-- doxytag: member="Kalman::EKFilter::makeBaseW" ref="fee4e2d5e2ee0e0b384328ef4b5acd10" args="()" -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00010.html#fee4e2d5e2ee0e0b384328ef4b5acd10">makeBaseW</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Virtual pre-creator of <em>W</em>. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00010.html#5df090d462672680b2727f9d777ecf38">makeBaseQ</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Virtual pre-creator of <em>Q</em>.  <a href="#5df090d462672680b2727f9d777ecf38"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="82beae7bd03ecf043dc2879020211a01"></a><!-- doxytag: member="Kalman::EKFilter::makeBaseH" ref="82beae7bd03ecf043dc2879020211a01" args="()" -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00010.html#82beae7bd03ecf043dc2879020211a01">makeBaseH</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Virtual pre-creator of <em>H</em>. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00010.html#328205b3d3440b18cdc7701ca961d40d">makeBaseV</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Virtual pre-creator of <em>V</em>.  <a href="#328205b3d3440b18cdc7701ca961d40d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00010.html#48cf2273a4cdeee90fedc917a3c509bb">makeBaseR</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Virtual pre-creator of <em>R</em>.  <a href="#48cf2273a4cdeee90fedc917a3c509bb"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Matrix Creators</div></td></tr>
<tr><td colspan="2"><div class="groupText">Theses functions have been designed to be overridden by derived classes if necessary. Their role is to fill in the parts of the Kalman matrices that change between iterations. That is to say, these functions should set values inside matrices that depend on <em>x</em> or <em>u</em>.<p>
These functions can suppose that their corresponding matrix pre-creator has been called at least once before. Also, <code>makeA()</code>, <code>makeW()</code>, <code>makeQ()</code> and <code>makeProcess()</code> can suppose that <code>makeCommonProcess()</code> is called every time just before it being called. Same thing for <code>makeH()</code>, <code>makeV()</code>, <code>makeR()</code> and <code>makeMeasure()</code> about <code>makeCommonMeasure()</code>.<p>
<dl compact><dt><b>Note:</b></dt><dd>Matrices have already been properly resized before these functions are called, so no further resizing is or should be necessary. <p>
If a matrix creator is overridden, but it does not modify in any way the matrix in certain execution paths, then the function <code>NoModification()</code> should be called in each of those execution paths so that the filter can optimize away some calculations. The default versions of the matrix creators only call <code>NoModification()</code> in their bodies. </dd></dl>
<dl compact><dt><b>Warning:</b></dt><dd>Each matrix creator cannot suppose that any other matrix creator will be called before or after it. One thing is sure : <code>makeCommon*</code>() is called first, then some of <code>make*</code>() and finally, <code>makeProcess()</code> or <code>makeMeasure()</code>. <p>
These functions can access <em>x</em> and <em>u</em> in read-only mode, except makeProcess(), which must modify <em>x</em>. </dd></dl>
<br><br></div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00010.html#00af959e9f2bb73e4a5ccecafd74617d">makeCommonProcess</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Optional function used to precalculate common values for process.  <a href="#00af959e9f2bb73e4a5ccecafd74617d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="fb6168f2a88d8674d1cfa349bd78263b"></a><!-- doxytag: member="Kalman::EKFilter::makeA" ref="fb6168f2a88d8674d1cfa349bd78263b" args="()" -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00010.html#fb6168f2a88d8674d1cfa349bd78263b">makeA</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Virtual creator of <em>A</em>. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="f1741e4ff0f84763d7207d4f418b0efb"></a><!-- doxytag: member="Kalman::EKFilter::makeW" ref="f1741e4ff0f84763d7207d4f418b0efb" args="()" -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00010.html#f1741e4ff0f84763d7207d4f418b0efb">makeW</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Virtual creator of <em>W</em>. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00010.html#a0e7ca750254434464c222094dbd14b2">makeQ</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Virtual creator of <em>Q</em>.  <a href="#a0e7ca750254434464c222094dbd14b2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00010.html#8caf231ab87d59bbc4b28ba840fc54d0">makeProcess</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Actual process <img class="formulaInl" alt="$ f(x, u, 0) $" src="form_51.png"> . Fills in new <em>x</em> by using old <em>x</em>.  <a href="#8caf231ab87d59bbc4b28ba840fc54d0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00010.html#b2368423153d84f471a49873224958ab">makeCommonMeasure</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Optional function used to precalculate common values for measurement.  <a href="#b2368423153d84f471a49873224958ab"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="0d915861910cdc17361f829d486de6a0"></a><!-- doxytag: member="Kalman::EKFilter::makeH" ref="0d915861910cdc17361f829d486de6a0" args="()" -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00010.html#0d915861910cdc17361f829d486de6a0">makeH</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Virtual creator of <em>H</em>. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00010.html#67f3a2a311f16ab10ce684dacc46b4ce">makeV</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Virtual creator of <em>V</em>.  <a href="#67f3a2a311f16ab10ce684dacc46b4ce"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00010.html#c8ed8c9c7a53f9f4108f64e5710ad926">makeR</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Virtual creator of <em>R</em>.  <a href="#c8ed8c9c7a53f9f4108f64e5710ad926"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00010.html#f27fd54297218f5dad3981ea67b0e235">makeMeasure</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Actual measurement function <img class="formulaInl" alt="$ h(x, 0) $" src="form_52.png"> . Fills in <em>z</em>.  <a href="#f27fd54297218f5dad3981ea67b0e235"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00010.html#df3cc66147296230b4e8da64460426be">makeDZ</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Hook-up function to modify innovation vector.  <a href="#df3cc66147296230b4e8da64460426be"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Protected Attributes</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Kalman Vectors and Matrices</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="a00015.html">Vector</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00010.html#9dd4e461268c8034f5c8564e155c67a6">x</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Corrected state vector.  <a href="#9dd4e461268c8034f5c8564e155c67a6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="a00015.html">Vector</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00010.html#7b774effe4a349c6dd82ad4f4f21d34c">u</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Input vector.  <a href="#7b774effe4a349c6dd82ad4f4f21d34c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="a00015.html">Vector</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00010.html#fbade9e36a3f36d3d676c1b808451dd7">z</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Predicted measurement vector.  <a href="#fbade9e36a3f36d3d676c1b808451dd7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="a00015.html">Vector</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00010.html#0de7b6a61a70688b26e6eeb3113531a3">dz</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Innovation vector.  <a href="#0de7b6a61a70688b26e6eeb3113531a3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="a00013.html">Matrix</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00010.html#7fc56270e7a70fa81a5935b72eacbe29">A</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A jacobian matrix.  <a href="#7fc56270e7a70fa81a5935b72eacbe29"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="a00013.html">Matrix</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00010.html#61e9c06ea9a85a5088a499df6458d276">W</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A jacobian matrix.  <a href="#61e9c06ea9a85a5088a499df6458d276"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="a00013.html">Matrix</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00010.html#f09564c9ca56850d4cd6b3319e541aee">Q</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Process noise covariance matrix.  <a href="#f09564c9ca56850d4cd6b3319e541aee"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="a00013.html">Matrix</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00010.html#c1d9f50f86825a1a2302ec2449c17196">H</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A jacobian matrix.  <a href="#c1d9f50f86825a1a2302ec2449c17196"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="a00013.html">Matrix</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00010.html#5206560a306a2e085a437fd258eb57ce">V</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A jacobian matrix.  <a href="#5206560a306a2e085a437fd258eb57ce"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="a00013.html">Matrix</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00010.html#e1e1d3d40573127e9ee0480caf1283d6">R</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Measurement noise covariance matrix.  <a href="#e1e1d3d40573127e9ee0480caf1283d6"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Kalman Dimensions</div></td></tr>
<tr><td colspan="2"><div class="groupText"><dl compact><dt><b>Warning:</b></dt><dd>These values, which are accessible to derived classes, are read-only. The derived classes should use the resizing functions to modify vector and matrix dimensions. </dd></dl>
<br><br></div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="7b8b965ad4bca0e41ab51de7b31363a1"></a><!-- doxytag: member="Kalman::EKFilter::n" ref="7b8b965ad4bca0e41ab51de7b31363a1" args="" -->
<a class="el" href="a00029.html#52dcd207f3e190d4f374ce16bdcd153f">K_UINT_32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00010.html#7b8b965ad4bca0e41ab51de7b31363a1">n</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Size of the state vector. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="0288bde0c2d593f2b5766f61b826a650"></a><!-- doxytag: member="Kalman::EKFilter::nu" ref="0288bde0c2d593f2b5766f61b826a650" args="" -->
<a class="el" href="a00029.html#52dcd207f3e190d4f374ce16bdcd153f">K_UINT_32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00010.html#0288bde0c2d593f2b5766f61b826a650">nu</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Size of the input vector. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="6a814fdcdf0ea6037af96b3de6f17750"></a><!-- doxytag: member="Kalman::EKFilter::nw" ref="6a814fdcdf0ea6037af96b3de6f17750" args="" -->
<a class="el" href="a00029.html#52dcd207f3e190d4f374ce16bdcd153f">K_UINT_32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00010.html#6a814fdcdf0ea6037af96b3de6f17750">nw</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Size of the process noise vector. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="6f8f57715090da2632453988d9a1501b"></a><!-- doxytag: member="Kalman::EKFilter::m" ref="6f8f57715090da2632453988d9a1501b" args="" -->
<a class="el" href="a00029.html#52dcd207f3e190d4f374ce16bdcd153f">K_UINT_32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00010.html#6f8f57715090da2632453988d9a1501b">m</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Size of the measurement vector. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="f9eab7a52fbda6f4788f438ba1a8da94"></a><!-- doxytag: member="Kalman::EKFilter::nv" ref="f9eab7a52fbda6f4788f438ba1a8da94" args="" -->
<a class="el" href="a00029.html#52dcd207f3e190d4f374ce16bdcd153f">K_UINT_32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00010.html#f9eab7a52fbda6f4788f438ba1a8da94">nv</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Size of the measurement noise vector. <br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
<h3>template&lt;typename T, K_UINT_32 BEG, bool OQ = false, bool OVR = false, bool DBG = true&gt;<br>
 class Kalman::EKFilter&lt; T, BEG, OQ, OVR, DBG &gt;</h3>

Generic Extended Kalman Filter (EKF) template base class. 
<p>
<dl compact><dt><b>Usage</b></dt><dd>"The Kalman filter is a set of mathematical equations that provides an efficient computational (recursive) solution of the least-squares method. The filter is very powerful in several aspects: it supports estimations of past, present, and even future states, and it can do so even when the precise nature of the modeled system is unknown." (quoted from [02]) <br>
 This version of the Kalman filter is in fact a Variable-Dimension Extended Kalman Filter (VDEKF). It supports optimized algorithms (translated from Fortran - see [01]), even in the presence of correlated process or measurement noise. <br>
 To use this template class, you must first inherit from it and implement some virtual functions. See the example page for more informations. Note that you can copy freely an <code>EKFilter-derived</code> class freely : this can be useful if you need to branch your filter based on some condition.</dd></dl>
<dl compact><dt><b>Notation</b></dt><dd>We prefered the notation of [02] : here it is. Assume a state vector <img class="formulaInl" alt="$ x $" src="form_37.png"> (to estimate) and a non-linear process function <img class="formulaInl" alt="$ f $" src="form_2.png"> (to model) that describes the evolution of this state through time, that is : <p class="formulaDsp">
<img class="formulaDsp" alt="\[ x_k = f \left( x_{k-1}, u_{k-1}, w_{k-1} \right) \]" src="form_38.png">
<p>
 where <img class="formulaInl" alt="$ u $" src="form_14.png"> is the (known) input vector fed to the process and <img class="formulaInl" alt="$ w $" src="form_4.png"> is the (unknown) process noise vector due to uncertainty and process modeling errors. Further suppose that the (known) process noise covariance matrix is : <p class="formulaDsp">
<img class="formulaDsp" alt="\[ Q = E \left( w w^T \right) \]" src="form_39.png">
<p>
 Now, let's assume a (known) measurement vector <img class="formulaInl" alt="$ z $" src="form_40.png"> , which depends on the current state <img class="formulaInl" alt="$ x $" src="form_37.png"> in the form of a non-linear function <img class="formulaInl" alt="$ h $" src="form_36.png"> (to model) : <p class="formulaDsp">
<img class="formulaDsp" alt="\[ z_k = h \left( x_k, v_k \right) \]" src="form_41.png">
<p>
 where <img class="formulaInl" alt="$ v $" src="form_7.png"> is the (unknown) measurement noise vector with a (known) covariance matrix : <p class="formulaDsp">
<img class="formulaDsp" alt="\[ R = E \left( v v^T \right) \]" src="form_42.png">
<p>
 Suppose that we have an estimate of the previous state <img class="formulaInl" alt="$ \hat{x}_{k-1} $" src="form_43.png"> , called a corrected state or an <em>a posteriori</em> state estimate. We can build a predicted state (also called an <em>a priori</em> state estimate) by using <img class="formulaInl" alt="$ f $" src="form_2.png"> : <p class="formulaDsp">
<img class="formulaDsp" alt="\[ \tilde{x}_k = f \left( \hat{x}_{k-1}, u_{k-1}, 0 \right) \]" src="form_44.png">
<p>
 since the input is known and the process noise, unknown. With this predicted state, we can get a predicted measurement vector by using <img class="formulaInl" alt="$ h $" src="form_36.png"> : <p class="formulaDsp">
<img class="formulaDsp" alt="\[ \tilde{z}_k = h \left( \tilde{x}_k, 0 \right) \]" src="form_45.png">
<p>
 since the measurement noise is unknown. To obtain a linear least-squares formulation, we need to linearize those two systems. Here are first-order Taylor series centered on <img class="formulaInl" alt="$ \tilde{x}_k $" src="form_46.png"> : <p class="formulaDsp">
<img class="formulaDsp" alt="\[ x_k \approx f \left( \hat{x}_{k-1}, u_{k-1}, 0 \right) + \frac{\partial f}{\partial x} \left( \hat{x}_{k-1}, u_{k-1}, 0 \right) \left( \Delta x \right) + \frac{\partial f}{\partial u} \left( \hat{x}_{k-1}, u_{k-1}, 0 \right) \left( \Delta u \right) + \frac{\partial f}{\partial w} \left( \hat{x}_{k-1}, u_{k-1}, 0 \right) \left( \Delta w \right) \]" src="form_47.png">
<p>
 <p class="formulaDsp">
<img class="formulaDsp" alt="\[ \phantom{x_k} = \tilde{x}_k + A \left( x_{k-1} - \hat{x}_{k-1} \right) + W w_{k-1} \]" src="form_48.png">
<p>
 We can do the same for the other system : <p class="formulaDsp">
<img class="formulaDsp" alt="\[ z_k \approx h \left( \tilde{x}_k, 0 \right) + \frac{\partial h}{\partial x} \left( \tilde{x}_k, 0 \right) \left( \Delta x \right) + \frac{\partial h}{\partial v} \left( \tilde{x}_k, 0 \right) \left( \Delta v \right) \]" src="form_49.png">
<p>
 <p class="formulaDsp">
<img class="formulaDsp" alt="\[ \phantom{z_k} = \tilde{z}_k + H \left( x_k - \tilde{x}_k \right) + V v_k \]" src="form_50.png">
<p>
 The user of this class must derive from it, and implement all the functions corresponding to <em>A</em>, <em>W</em>, <em>Q</em>, f, <em>H</em>, <em>V</em>, <em>R</em> and h.</dd></dl>
<dl compact><dt><b>References</b></dt><dd>[01] Bierman, G. J. "Factorization Methods for Discrete Sequential Estimation", Academic Press, 1977. <br>
 [02] Welch, G. and Bishop, G. "An Introduction to the %Kalman Filter", <a href="http://www.cs.unc.edu/~welch/kalman/kalmanIntro.html">http://www.cs.unc.edu/~welch/kalman/kalmanIntro.html</a></dd></dl>
<dl compact><dt><b>Template parameters</b></dt><dd><ul>
<li><code>T</code> : Type of elements contained in matrices and vectors. Usually <code>float</code> or <code>double</code>.</li><li><code>BEG</code> : Starting index of matrices and vectors. Can be either 0 or 1.</li><li><code>OQ</code> : Optimize calculations on <em>Q</em>. This can be turned on if <em>Q</em> is diagonal.</li><li><code>OVR</code> : Optimize calculations on <em>V</em> and <em>R</em>. This can be turned on if <em>V</em> and <em>R</em> are both diagonal matrices.</li><li><code>DGB</code> : Debug flag. If <code>true</code>, then bound-checking will be performed, and <code><a class="el" href="a00017.html">OutOfBoundError</a></code> exceptions can be thrown.</li></ul>
</dd></dl>
<dl compact><dt><b>Type requirements for T</b></dt><dd><ul>
<li><code>T</code> must be <b>default constructible</b>.</li><li><code>T</code> must be <b>constructible from</b> <code>double</code>.</li><li><code>T</code> must be <b>assignable</b>.</li><li><code>T</code> must be <b>equality comparable</b>.</li><li><code>T</code> must be <b>serializable</b>.</li><li><code>T</code> must support <b>basic arithmetic operations</b>.</li></ul>
This means that, if <code>t1</code>, <code>t2</code> are instances of <code>T</code>, <code>op</code> is an arithmetic operator (+ - * /), <code>is</code> is of type <code>istream</code> and <code>os</code> is of type <code>ostream</code>, the following expressions must be valid : -<div class="fragment"><pre class="fragment"> T(); T t1; 
</pre></div> Default constructor -<div class="fragment"><pre class="fragment"> T(0.0); T t1(1.0); 
</pre></div> Constructor from <code>double</code> -<div class="fragment"><pre class="fragment"> T t1 = t2; T t1(t2); T(t1); 
</pre></div> Copy constructor -<div class="fragment"><pre class="fragment"> t1 op t2 
</pre></div> Arithmetic operation, convertible to <code>T</code> -<div class="fragment"><pre class="fragment"> -t1 
</pre></div> Negation operator, convertible to <code>T</code>. Same as :<div class="fragment"><pre class="fragment"> T(0.0) - t1; 
</pre></div> -<div class="fragment"><pre class="fragment"> t1 = t2; 
</pre></div> Assignment operator -<div class="fragment"><pre class="fragment"> t1 op= t2; 
</pre></div> Arithmetic inplace operation. Same as :<div class="fragment"><pre class="fragment"> t1 = t1 op t2; 
</pre></div> -<div class="fragment"><pre class="fragment"> t1 == t2 
</pre></div> Equality comparison, convertible to <code>bool</code> -<div class="fragment"><pre class="fragment"> is &gt;&gt; t1; 
</pre></div> <code><a class="el" href="a00029.html#1b0749aa5a616ca84f2faef213eb99c5">operator&gt;&gt;()</a></code> -<div class="fragment"><pre class="fragment"> os &lt;&lt; t1; 
</pre></div> <code><a class="el" href="a00029.html#306ddf487102c0e25d151c15d1a2e4f4">operator&lt;&lt;()</a></code> </dd></dl>
Finally, note that <code><a class="el" href="a00029.html#1b0749aa5a616ca84f2faef213eb99c5">operator&gt;&gt;()</a></code> and <code><a class="el" href="a00029.html#306ddf487102c0e25d151c15d1a2e4f4">operator&lt;&lt;()</a></code> must be compatible. Also, <code>operator&amp;()</code> must not have been overloaded. 
<p>
<hr><h2>Member Enumeration Documentation</h2>
<a class="anchor" name="dca29a1140aadadfd92b34a02fa516ef"></a><!-- doxytag: member="Kalman::EKFilter::@0" ref="dca29a1140aadadfd92b34a02fa516ef" args="" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;typename T, K_UINT_32 BEG, bool OQ = false, bool OVR = false, bool DBG = true&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top">anonymous enum          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<dl compact><dt><b>Enumerator: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" name="dca29a1140aadadfd92b34a02fa516ef63a08f52a29e0f7a1f987f4495164ab0"></a><!-- doxytag: member="beg" ref="dca29a1140aadadfd92b34a02fa516ef63a08f52a29e0f7a1f987f4495164ab0" args="" -->beg</em>&nbsp;</td><td>
Starting index of matrices and vectors. </td></tr>
</table>
</dl>
    </td>
  </tr>
</table>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="4f5276a8a88934d273fb4f761ab01b95"></a><!-- doxytag: member="Kalman::EKFilter::EKFilter" ref="4f5276a8a88934d273fb4f761ab01b95" args="(K_UINT_32 n_, K_UINT_32 nu_, K_UINT_32 nw_, K_UINT_32 m_, K_UINT_32 nv_)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;typename T, K_UINT_32 BEG, bool OQ, bool OVR, bool DBG&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="a00010.html">Kalman::EKFilter</a>&lt; T, BEG, OQ, OVR, DBG &gt;::<a class="el" href="a00010.html">EKFilter</a>           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="a00029.html#52dcd207f3e190d4f374ce16bdcd153f">K_UINT_32</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>n_</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="a00029.html#52dcd207f3e190d4f374ce16bdcd153f">K_UINT_32</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>nu_</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="a00029.html#52dcd207f3e190d4f374ce16bdcd153f">K_UINT_32</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>nw_</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="a00029.html#52dcd207f3e190d4f374ce16bdcd153f">K_UINT_32</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>m_</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="a00029.html#52dcd207f3e190d4f374ce16bdcd153f">K_UINT_32</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>nv_</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Constructors specifying all necessary matrix and vector dimensions. 
<p>
This constructor simply calls <code><a class="el" href="a00010.html#23101e8b17b27d57b1bf2668904bf4ec">setDim()</a></code> with all the corresponding arguments.     </td>
  </tr>
</table>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="23101e8b17b27d57b1bf2668904bf4ec"></a><!-- doxytag: member="Kalman::EKFilter::setDim" ref="23101e8b17b27d57b1bf2668904bf4ec" args="(K_UINT_32 n_, K_UINT_32 nu_, K_UINT_32 nw_, K_UINT_32 m_, K_UINT_32 nv_)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;typename T, K_UINT_32 BEG, bool OQ, bool OVR, bool DBG&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top">void <a class="el" href="a00010.html">Kalman::EKFilter</a>&lt; T, BEG, OQ, OVR, DBG &gt;::setDim           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="a00029.html#52dcd207f3e190d4f374ce16bdcd153f">K_UINT_32</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>n_</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="a00029.html#52dcd207f3e190d4f374ce16bdcd153f">K_UINT_32</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>nu_</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="a00029.html#52dcd207f3e190d4f374ce16bdcd153f">K_UINT_32</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>nw_</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="a00029.html#52dcd207f3e190d4f374ce16bdcd153f">K_UINT_32</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>m_</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="a00029.html#52dcd207f3e190d4f374ce16bdcd153f">K_UINT_32</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>nv_</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Sets all dimensions at once. 
<p>
This function simply calls the <code>setSize*</code>() functions for <code>x, u, w, z, v</code> with the corresponding arguments. <dl compact><dt><b>Warning:</b></dt><dd>This function (or the corresponding five <code>setSize*</code>() functions) must be called before any other functions. <p>
<code><a class="el" href="a00010.html#50886bc1066141f71bd94296cd8ad676">init()</a></code> must always be called after this function and before any other non-dimensioning function. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="5d3999b77ab3165b6c2b0b8b8f192139"></a><!-- doxytag: member="Kalman::EKFilter::setSizeX" ref="5d3999b77ab3165b6c2b0b8b8f192139" args="(K_UINT_32 n_)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;typename T, K_UINT_32 BEG, bool OQ, bool OVR, bool DBG&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top">void <a class="el" href="a00010.html">Kalman::EKFilter</a>&lt; T, BEG, OQ, OVR, DBG &gt;::setSizeX           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="a00029.html#52dcd207f3e190d4f374ce16bdcd153f">K_UINT_32</a>&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>n_</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Sets the size of the state vector. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>n_</em>&nbsp;</td><td>New state vector size. Must not be 0. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Warning:</b></dt><dd><code><a class="el" href="a00010.html#50886bc1066141f71bd94296cd8ad676">init()</a></code> must always be called after this function and before any other non-dimensioning function. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ef9e77d7e4d0e9c963456455ba5b85cc"></a><!-- doxytag: member="Kalman::EKFilter::setSizeW" ref="ef9e77d7e4d0e9c963456455ba5b85cc" args="(K_UINT_32 nw_)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;typename T, K_UINT_32 BEG, bool OQ, bool OVR, bool DBG&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top">void <a class="el" href="a00010.html">Kalman::EKFilter</a>&lt; T, BEG, OQ, OVR, DBG &gt;::setSizeW           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="a00029.html#52dcd207f3e190d4f374ce16bdcd153f">K_UINT_32</a>&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>nw_</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Sets the size of the process noise vector. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>nw_</em>&nbsp;</td><td>New process noise vector size. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Warning:</b></dt><dd><code><a class="el" href="a00010.html#50886bc1066141f71bd94296cd8ad676">init()</a></code> must always be called after this function and before any other non-dimensioning function. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="50886bc1066141f71bd94296cd8ad676"></a><!-- doxytag: member="Kalman::EKFilter::init" ref="50886bc1066141f71bd94296cd8ad676" args="(Vector &amp;x_, Matrix &amp;P_)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;typename T, K_UINT_32 BEG, bool OQ, bool OVR, bool DBG&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top">void <a class="el" href="a00010.html">Kalman::EKFilter</a>&lt; T, BEG, OQ, OVR, DBG &gt;::init           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="a00015.html">Vector</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>x_</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="a00013.html">Matrix</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>P_</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Sets initial conditions for the Kalman Filter. 
<p>
This function allows to set an initial state estimate vector and an initial error covariance matrix estimate. This must be called at least once, after all dimensioning functions and before any other function. However, it can also be called anytime to reset or modify <em>x</em> or <em>P</em>. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>x_</em>&nbsp;</td><td>State vector estimate. Will be destroyed. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>P_</em>&nbsp;</td><td>Error covariance matrix estimate. Will be destroyed. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Warning:</b></dt><dd>If <code><a class="el" href="a00010.html#23101e8b17b27d57b1bf2668904bf4ec">setDim()</a></code>, <code><a class="el" href="a00010.html#5d3999b77ab3165b6c2b0b8b8f192139">setSizeX()</a></code> or <code><a class="el" href="a00010.html#ef9e77d7e4d0e9c963456455ba5b85cc">setSizeW()</a></code> is called, then <a class="el" href="a00010.html#50886bc1066141f71bd94296cd8ad676">init()</a> must be called again before any other non-dimensioning function. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="9ce43496cd9547c192ba45ffd3e93d13"></a><!-- doxytag: member="Kalman::EKFilter::step" ref="9ce43496cd9547c192ba45ffd3e93d13" args="(Vector &amp;u_, const Vector &amp;z_)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;typename T, K_UINT_32 BEG, bool OQ, bool OVR, bool DBG&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top">void <a class="el" href="a00010.html">Kalman::EKFilter</a>&lt; T, BEG, OQ, OVR, DBG &gt;::step           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="a00015.html">Vector</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>u_</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const <a class="el" href="a00015.html">Vector</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>z_</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Makes one prediction-correction step. 
<p>
This is the main <code><a class="el" href="a00010.html">EKFilter</a></code> function. First, it resizes any matrix who needs it. Then, it proceeds to the time update phase, using the input vector <code>u_</code>. This means that the following virtual functions <em>should be</em> called : <code><a class="el" href="a00010.html#00af959e9f2bb73e4a5ccecafd74617d">makeCommonProcess()</a></code>, <code><a class="el" href="a00010.html#fb6168f2a88d8674d1cfa349bd78263b">makeA()</a></code>, <code><a class="el" href="a00010.html#f1741e4ff0f84763d7207d4f418b0efb">makeW()</a></code>, <code><a class="el" href="a00010.html#a0e7ca750254434464c222094dbd14b2">makeQ()</a></code> and <code><a class="el" href="a00010.html#8caf231ab87d59bbc4b28ba840fc54d0">makeProcess()</a></code>. At this stage, <em>x</em> contains a current predicted state instead of an old corrected state. If <code>z_</code> is empty, that is, if there are no measures in this step, there is no correction and the function stops there. Else, the measure update phase begins. This means that the following virtual functions <em>should be</em> called : <code><a class="el" href="a00010.html#b2368423153d84f471a49873224958ab">makeCommonMeasure()</a></code>, <code>makeHImpl()</code>, <code>makeVImpl()</code>, <code>makeRImpl()</code>, <code><a class="el" href="a00010.html#f27fd54297218f5dad3981ea67b0e235">makeMeasure()</a></code> and <code><a class="el" href="a00010.html#df3cc66147296230b4e8da64460426be">makeDZ()</a></code>.After this phase, <em>x</em> contains the new corrected state. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>u_</em>&nbsp;</td><td>Input vector. Will <b>not</b> be destroyed. Can be empty. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>z_</em>&nbsp;</td><td>Measurement vector. Will <b>not</b> be destroyed. Can be empty. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="fd603471b0a9b0c188fc5ac00b993752"></a><!-- doxytag: member="Kalman::EKFilter::timeUpdateStep" ref="fd603471b0a9b0c188fc5ac00b993752" args="(Vector &amp;u_)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;typename T, K_UINT_32 BEG, bool OQ, bool OVR, bool DBG&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top">void <a class="el" href="a00010.html">Kalman::EKFilter</a>&lt; T, BEG, OQ, OVR, DBG &gt;::timeUpdateStep           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="a00015.html">Vector</a> &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>u_</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Makes one prediction step. 
<p>
This function first resizes any matrix who needs it. Then, it proceeds to the time update phase, using the input vector <code>u_</code>. This means that the following virtual functions <em>should be</em> called : <code><a class="el" href="a00010.html#00af959e9f2bb73e4a5ccecafd74617d">makeCommonProcess()</a></code>, <code><a class="el" href="a00010.html#fb6168f2a88d8674d1cfa349bd78263b">makeA()</a></code>, <code><a class="el" href="a00010.html#f1741e4ff0f84763d7207d4f418b0efb">makeW()</a></code>, <code><a class="el" href="a00010.html#a0e7ca750254434464c222094dbd14b2">makeQ()</a></code> and <code><a class="el" href="a00010.html#8caf231ab87d59bbc4b28ba840fc54d0">makeProcess()</a></code>. At this stage, <em>x</em> contains a current predicted state instead of an old corrected state. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>u_</em>&nbsp;</td><td>Input vector. Will <b>not</b> be destroyed. Can be empty. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="68983cf3280fc4b7e99ffda7b76bb684"></a><!-- doxytag: member="Kalman::EKFilter::measureUpdateStep" ref="68983cf3280fc4b7e99ffda7b76bb684" args="(const Vector &amp;z_)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;typename T, K_UINT_32 BEG, bool OQ, bool OVR, bool DBG&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top">void <a class="el" href="a00010.html">Kalman::EKFilter</a>&lt; T, BEG, OQ, OVR, DBG &gt;::measureUpdateStep           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="a00015.html">Vector</a> &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>z_</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Makes one correction step. 
<p>
First, this function resizes any matrix who needs it. If <code>z_</code> is empty, that is, if there are no measures in this step, there is no correction and the function stops there. Else, the measure update phase begins. This means that the following virtual functions <em>should be</em> called : <code><a class="el" href="a00010.html#b2368423153d84f471a49873224958ab">makeCommonMeasure()</a></code>, <code>makeHImpl()</code>, <code>makeVImpl()</code>, <code>makeRImpl()</code>, <code><a class="el" href="a00010.html#f27fd54297218f5dad3981ea67b0e235">makeMeasure()</a></code> and <code><a class="el" href="a00010.html#df3cc66147296230b4e8da64460426be">makeDZ()</a></code>.After this phase, <em>x</em> contains the new corrected state. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>z_</em>&nbsp;</td><td>Measurement vector. Will <b>not</b> be destroyed. Can be empty. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="fc92e7081f91b62523576c1b3536e4b3"></a><!-- doxytag: member="Kalman::EKFilter::predict" ref="fc92e7081f91b62523576c1b3536e4b3" args="(Vector &amp;u_)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;typename T, K_UINT_32 BEG, bool OQ, bool OVR, bool DBG&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top">const <a class="el" href="a00010.html">EKFilter</a>&lt; T, BEG, OQ, OVR, DBG &gt;::<a class="el" href="a00015.html">Vector</a> &amp; <a class="el" href="a00010.html">Kalman::EKFilter</a>&lt; T, BEG, OQ, OVR, DBG &gt;::predict           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="a00015.html">Vector</a> &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>u_</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns the predicted state vector (<em>a priori</em> state estimate). 
<p>
This function is used to predict a future state. First, it resizes any matrix who needs it. Then, it does a partial time update, in the sense that only <em>x</em> is updated, not P. This also means that only the following virtual functions <em>should be</em> called : <code><a class="el" href="a00010.html#00af959e9f2bb73e4a5ccecafd74617d">makeCommonProcess()</a></code> and <code><a class="el" href="a00010.html#8caf231ab87d59bbc4b28ba840fc54d0">makeProcess()</a></code>. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>u_</em>&nbsp;</td><td>Input vector. Will <b>not</b> be destroyed. Can be empty. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Note:</b></dt><dd>The real <em>x</em> is not modified by this function (this is a <code>const</code> function). Only a copy of <em>x</em> is returned. </dd></dl>
<dl compact><dt><b>Warning:</b></dt><dd>For better efficiency, the prediction is returned by reference. The reference points to an internal member of the filter, which means that a new prediction (and many other functions) will invalidate the contents of this vector. This also means that this vector must be copied (or better yet, swapped) as soon as possible if its data is needed later. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="8e2a9f50c3301dc17bd68c58396369a5"></a><!-- doxytag: member="Kalman::EKFilter::simulate" ref="8e2a9f50c3301dc17bd68c58396369a5" args="()" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;typename T, K_UINT_32 BEG, bool OQ, bool OVR, bool DBG&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top">const <a class="el" href="a00010.html">EKFilter</a>&lt; T, BEG, OQ, OVR, DBG &gt;::<a class="el" href="a00015.html">Vector</a> &amp; <a class="el" href="a00010.html">Kalman::EKFilter</a>&lt; T, BEG, OQ, OVR, DBG &gt;::simulate           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns the predicted measurement vector. 
<p>
This function is used to predict a future measurement. First, it resizes any matrix who needs it. Then, it does a partial measure update, in the sense that only <em>z</em> is calculated : <em>x</em> and P are not updated. This also means that only the following virtual functions <em>should be</em> called : <code><a class="el" href="a00010.html#b2368423153d84f471a49873224958ab">makeCommonMeasure()</a></code> and <code><a class="el" href="a00010.html#f27fd54297218f5dad3981ea67b0e235">makeMeasure()</a></code>. <dl compact><dt><b>Note:</b></dt><dd>This is a <code>const</code> function. It only works on copies of vectors. </dd></dl>
<dl compact><dt><b>Warning:</b></dt><dd>For better efficiency, the prediction is returned by reference. The reference points to an internal member of the filter, which means that a new prediction (and many other functions) will invalidate the contents of this vector. This also means that this vector must be copied (or better yet, swapped) as soon as possible if its data is needed later. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ac0985755b9fbeb6330aef0c34546a91"></a><!-- doxytag: member="Kalman::EKFilter::calculateP" ref="ac0985755b9fbeb6330aef0c34546a91" args="() const " --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;typename T, K_UINT_32 BEG, bool OQ, bool OVR, bool DBG&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top">const <a class="el" href="a00010.html">EKFilter</a>&lt; T, BEG, OQ, OVR, DBG &gt;::<a class="el" href="a00013.html">Matrix</a> &amp; <a class="el" href="a00010.html">Kalman::EKFilter</a>&lt; T, BEG, OQ, OVR, DBG &gt;::calculateP           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const</td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns the <em>a posteriori</em> error covariance estimate matrix. 
<p>
<dl compact><dt><b>Warning:</b></dt><dd>This is not a simple return statement. Since P is not kept and updated in the filter (an alternate and more stable representation of P is used), calculations are involved to retrieve P. So, use this function wisely. <p>
For better efficiency, P is returned by reference. The reference points to an internal member of the filter, which means that other functions may invalidate the contents of this matrix. This also means that this matrix must be copied (or better yet, swapped) as soon as possible if its data is needed later. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="bfca7d629f94d7954e48597108e0ba21"></a><!-- doxytag: member="Kalman::EKFilter::NoModification" ref="bfca7d629f94d7954e48597108e0ba21" args="()" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;typename T, K_UINT_32 BEG, bool OQ, bool OVR, bool DBG&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top">void <a class="el" href="a00010.html">Kalman::EKFilter</a>&lt; T, BEG, OQ, OVR, DBG &gt;::NoModification           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [protected]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Allows optimizations on some calculations. 
<p>
By default, the <a class="el" href="a00010.html">EKFilter</a> template class suppose that matrix pre-creators and creators modify all matrices. However, if it could suppose that some of these functions do not modify anything, some calculations could be optimized away. The <code><a class="el" href="a00010.html#bfca7d629f94d7954e48597108e0ba21">NoModification()</a></code> function says that the function in which it has been called has not modified any matrix. For optimization purposes, this means that this function should be called in every non-mutating execution branch of all <code>make*</code>() and <code>makeBase*</code>() functions.     </td>
  </tr>
</table>
<a class="anchor" name="5df090d462672680b2727f9d777ecf38"></a><!-- doxytag: member="Kalman::EKFilter::makeBaseQ" ref="5df090d462672680b2727f9d777ecf38" args="()" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;typename T, K_UINT_32 BEG, bool OQ, bool OVR, bool DBG&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top">void <a class="el" href="a00010.html">Kalman::EKFilter</a>&lt; T, BEG, OQ, OVR, DBG &gt;::makeBaseQ           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [protected, virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Virtual pre-creator of <em>Q</em>. 
<p>
<dl compact><dt><b>Note:</b></dt><dd>If <code>OQ</code> is <code>true</code>, that is, if <code>Q</code> is always diagonal, then it is not necessary to initialize non-diagonal elements with anything meaningful. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="328205b3d3440b18cdc7701ca961d40d"></a><!-- doxytag: member="Kalman::EKFilter::makeBaseV" ref="328205b3d3440b18cdc7701ca961d40d" args="()" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;typename T, K_UINT_32 BEG, bool OQ, bool OVR, bool DBG&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top">void <a class="el" href="a00010.html">Kalman::EKFilter</a>&lt; T, BEG, OQ, OVR, DBG &gt;::makeBaseV           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [protected, virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Virtual pre-creator of <em>V</em>. 
<p>
<dl compact><dt><b>Note:</b></dt><dd>If <code>OVR</code> is <code>true</code>, that is, if <code>both</code> V and R are always diagonal, then it is not necessary to initialize non-diagonal elements with anything meaningful. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="48cf2273a4cdeee90fedc917a3c509bb"></a><!-- doxytag: member="Kalman::EKFilter::makeBaseR" ref="48cf2273a4cdeee90fedc917a3c509bb" args="()" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;typename T, K_UINT_32 BEG, bool OQ, bool OVR, bool DBG&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top">void <a class="el" href="a00010.html">Kalman::EKFilter</a>&lt; T, BEG, OQ, OVR, DBG &gt;::makeBaseR           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [protected, virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Virtual pre-creator of <em>R</em>. 
<p>
<dl compact><dt><b>Note:</b></dt><dd>If <code>OVR</code> is <code>true</code>, that is, if <code>both</code> V and R are always diagonal, then it is not necessary to initialize non-diagonal elements with anything meaningful. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="00af959e9f2bb73e4a5ccecafd74617d"></a><!-- doxytag: member="Kalman::EKFilter::makeCommonProcess" ref="00af959e9f2bb73e4a5ccecafd74617d" args="()" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;typename T, K_UINT_32 BEG, bool OQ, bool OVR, bool DBG&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top">void <a class="el" href="a00010.html">Kalman::EKFilter</a>&lt; T, BEG, OQ, OVR, DBG &gt;::makeCommonProcess           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [protected, virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Optional function used to precalculate common values for process. 
<p>
If complex calculations are needed for more than one of <code><a class="el" href="a00010.html#fb6168f2a88d8674d1cfa349bd78263b">makeA()</a></code>, <code><a class="el" href="a00010.html#f1741e4ff0f84763d7207d4f418b0efb">makeW()</a></code>, <code><a class="el" href="a00010.html#a0e7ca750254434464c222094dbd14b2">makeQ()</a></code> and <code><a class="el" href="a00010.html#8caf231ab87d59bbc4b28ba840fc54d0">makeProcess()</a></code> functions, then this function can be used to store the results in temporary variables of the derived class. <dl compact><dt><b>Warning:</b></dt><dd>This function must not modify any matrix of the base class. <p>
This function must not be used to store permanent state. In other words, all calculations performed in this function should be temporary. This is because the <code><a class="el" href="a00010.html#fc92e7081f91b62523576c1b3536e4b3">predict()</a></code> function will call this function but has no knowledge of how to undo it. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a0e7ca750254434464c222094dbd14b2"></a><!-- doxytag: member="Kalman::EKFilter::makeQ" ref="a0e7ca750254434464c222094dbd14b2" args="()" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;typename T, K_UINT_32 BEG, bool OQ, bool OVR, bool DBG&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top">void <a class="el" href="a00010.html">Kalman::EKFilter</a>&lt; T, BEG, OQ, OVR, DBG &gt;::makeQ           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [protected, virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Virtual creator of <em>Q</em>. 
<p>
<dl compact><dt><b>Note:</b></dt><dd>If <code>OQ</code> is <code>true</code>, that is, if <code>Q</code> is always diagonal, then it is not necessary to initialize non-diagonal elements with anything meaningful. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="8caf231ab87d59bbc4b28ba840fc54d0"></a><!-- doxytag: member="Kalman::EKFilter::makeProcess" ref="8caf231ab87d59bbc4b28ba840fc54d0" args="()=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;typename T, K_UINT_32 BEG, bool OQ = false, bool OVR = false, bool DBG = true&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top">virtual void <a class="el" href="a00010.html">Kalman::EKFilter</a>&lt; T, BEG, OQ, OVR, DBG &gt;::makeProcess           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [protected, pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Actual process <img class="formulaInl" alt="$ f(x, u, 0) $" src="form_51.png"> . Fills in new <em>x</em> by using old <em>x</em>. 
<p>
This function <b>must</b> be overridden, since it is the core of the system process. <dl compact><dt><b>Warning:</b></dt><dd>This function should have no side effects to class members (even members of derived classes) other than <em>x</em>. This is because this function is used by <code><a class="el" href="a00010.html#fc92e7081f91b62523576c1b3536e4b3">predict()</a></code>, which does a calculation and then undoes it before returning the result. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="b2368423153d84f471a49873224958ab"></a><!-- doxytag: member="Kalman::EKFilter::makeCommonMeasure" ref="b2368423153d84f471a49873224958ab" args="()" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;typename T, K_UINT_32 BEG, bool OQ, bool OVR, bool DBG&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top">void <a class="el" href="a00010.html">Kalman::EKFilter</a>&lt; T, BEG, OQ, OVR, DBG &gt;::makeCommonMeasure           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [protected, virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Optional function used to precalculate common values for measurement. 
<p>
If complex calculations are needed for more than one of <code><a class="el" href="a00010.html#0d915861910cdc17361f829d486de6a0">makeH()</a></code>, <code><a class="el" href="a00010.html#67f3a2a311f16ab10ce684dacc46b4ce">makeV()</a></code>, <code><a class="el" href="a00010.html#c8ed8c9c7a53f9f4108f64e5710ad926">makeR()</a></code>, <code><a class="el" href="a00010.html#f27fd54297218f5dad3981ea67b0e235">makeMeasure()</a></code> and <code><a class="el" href="a00010.html#df3cc66147296230b4e8da64460426be">makeDZ()</a></code> functions, then this function can be used to store the results in temporary variables of the derived class. <dl compact><dt><b>Warning:</b></dt><dd>This function must not modify any matrix of the base class. <p>
This function must not be used to store permanent state. In other words, all calculations performed in this function should be temporary. This is because the <code><a class="el" href="a00010.html#8e2a9f50c3301dc17bd68c58396369a5">simulate()</a></code> function will call this function but has no knowledge of how to undo it. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="67f3a2a311f16ab10ce684dacc46b4ce"></a><!-- doxytag: member="Kalman::EKFilter::makeV" ref="67f3a2a311f16ab10ce684dacc46b4ce" args="()" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;typename T, K_UINT_32 BEG, bool OQ, bool OVR, bool DBG&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top">void <a class="el" href="a00010.html">Kalman::EKFilter</a>&lt; T, BEG, OQ, OVR, DBG &gt;::makeV           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [protected, virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Virtual creator of <em>V</em>. 
<p>
<dl compact><dt><b>Note:</b></dt><dd>If <code>OVR</code> is <code>true</code>, that is, if <code>both</code> V and R are always diagonal, then it is not necessary to initialize non-diagonal elements with anything meaningful. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="c8ed8c9c7a53f9f4108f64e5710ad926"></a><!-- doxytag: member="Kalman::EKFilter::makeR" ref="c8ed8c9c7a53f9f4108f64e5710ad926" args="()" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;typename T, K_UINT_32 BEG, bool OQ, bool OVR, bool DBG&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top">void <a class="el" href="a00010.html">Kalman::EKFilter</a>&lt; T, BEG, OQ, OVR, DBG &gt;::makeR           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [protected, virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Virtual creator of <em>R</em>. 
<p>
<dl compact><dt><b>Note:</b></dt><dd>If <code>OVR</code> is <code>true</code>, that is, if <code>both</code> V and R are always diagonal, then it is not necessary to initialize non-diagonal elements with anything meaningful. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="f27fd54297218f5dad3981ea67b0e235"></a><!-- doxytag: member="Kalman::EKFilter::makeMeasure" ref="f27fd54297218f5dad3981ea67b0e235" args="()=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;typename T, K_UINT_32 BEG, bool OQ = false, bool OVR = false, bool DBG = true&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top">virtual void <a class="el" href="a00010.html">Kalman::EKFilter</a>&lt; T, BEG, OQ, OVR, DBG &gt;::makeMeasure           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [protected, pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Actual measurement function <img class="formulaInl" alt="$ h(x, 0) $" src="form_52.png"> . Fills in <em>z</em>. 
<p>
This function <b>must</b> be overridden, since it is the core of the measurement system. At the time this will be called, <em>x</em> contains the predicted state (<em>a priori</em> state estimate), which is the one that must be used with the measurement function. <dl compact><dt><b>Warning:</b></dt><dd>This function should have no side effects to class members (even members of derived classes) other than <em>z</em>. This is because this function is used by <code><a class="el" href="a00010.html#8e2a9f50c3301dc17bd68c58396369a5">simulate()</a></code>, which does a calculation and then undoes it before returning the result. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="df3cc66147296230b4e8da64460426be"></a><!-- doxytag: member="Kalman::EKFilter::makeDZ" ref="df3cc66147296230b4e8da64460426be" args="()" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;typename T, K_UINT_32 BEG, bool OQ, bool OVR, bool DBG&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top">void <a class="el" href="a00010.html">Kalman::EKFilter</a>&lt; T, BEG, OQ, OVR, DBG &gt;::makeDZ           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [protected, virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Hook-up function to modify innovation vector. 
<p>
This function should rarely be overridden ; this is more of a hack than anything else. In fact, this is used to perform adjustements on the result of substracting the predicted measurement vector to the real measurement vector. This is needed, for example, when measures include angles. It may be mandatory that the difference of the two angles be in a certain range, like <img class="formulaInl" alt="$ [-\pi, \pi] $" src="form_53.png"> .     </td>
  </tr>
</table>
<hr><h2>Member Data Documentation</h2>
<a class="anchor" name="9dd4e461268c8034f5c8564e155c67a6"></a><!-- doxytag: member="Kalman::EKFilter::x" ref="9dd4e461268c8034f5c8564e155c67a6" args="" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;typename T, K_UINT_32 BEG, bool OQ = false, bool OVR = false, bool DBG = true&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="a00015.html">Vector</a> <a class="el" href="a00010.html">Kalman::EKFilter</a>&lt; T, BEG, OQ, OVR, DBG &gt;::<a class="el" href="a00010.html#9dd4e461268c8034f5c8564e155c67a6">x</a><code> [protected]</code>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Corrected state vector. 
<p>
This is an <em>n-sized</em> vector. Derived classes should modify it only through <code><a class="el" href="a00010.html#8caf231ab87d59bbc4b28ba840fc54d0">makeProcess()</a></code>.     </td>
  </tr>
</table>
<a class="anchor" name="7b774effe4a349c6dd82ad4f4f21d34c"></a><!-- doxytag: member="Kalman::EKFilter::u" ref="7b774effe4a349c6dd82ad4f4f21d34c" args="" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;typename T, K_UINT_32 BEG, bool OQ = false, bool OVR = false, bool DBG = true&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="a00015.html">Vector</a> <a class="el" href="a00010.html">Kalman::EKFilter</a>&lt; T, BEG, OQ, OVR, DBG &gt;::<a class="el" href="a00010.html#7b774effe4a349c6dd82ad4f4f21d34c">u</a><code> [protected]</code>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Input vector. 
<p>
This is an <em>nu-sized</em> vector. Derived classes should never modify it.     </td>
  </tr>
</table>
<a class="anchor" name="fbade9e36a3f36d3d676c1b808451dd7"></a><!-- doxytag: member="Kalman::EKFilter::z" ref="fbade9e36a3f36d3d676c1b808451dd7" args="" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;typename T, K_UINT_32 BEG, bool OQ = false, bool OVR = false, bool DBG = true&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="a00015.html">Vector</a> <a class="el" href="a00010.html">Kalman::EKFilter</a>&lt; T, BEG, OQ, OVR, DBG &gt;::<a class="el" href="a00010.html#fbade9e36a3f36d3d676c1b808451dd7">z</a><code> [protected]</code>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Predicted measurement vector. 
<p>
This is an <em>m-sized</em> vector. Derived classes should modify it only through <code><a class="el" href="a00010.html#f27fd54297218f5dad3981ea67b0e235">makeMeasure()</a></code>.     </td>
  </tr>
</table>
<a class="anchor" name="0de7b6a61a70688b26e6eeb3113531a3"></a><!-- doxytag: member="Kalman::EKFilter::dz" ref="0de7b6a61a70688b26e6eeb3113531a3" args="" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;typename T, K_UINT_32 BEG, bool OQ = false, bool OVR = false, bool DBG = true&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="a00015.html">Vector</a> <a class="el" href="a00010.html">Kalman::EKFilter</a>&lt; T, BEG, OQ, OVR, DBG &gt;::<a class="el" href="a00010.html#0de7b6a61a70688b26e6eeb3113531a3">dz</a><code> [protected]</code>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Innovation vector. 
<p>
This is an <em>m-sized</em> vector. Derived classes should modify it only through <code><a class="el" href="a00010.html#df3cc66147296230b4e8da64460426be">makeDZ()</a></code>. The innovation vector is the difference between the real measurement vector and the predicted one.     </td>
  </tr>
</table>
<a class="anchor" name="7fc56270e7a70fa81a5935b72eacbe29"></a><!-- doxytag: member="Kalman::EKFilter::A" ref="7fc56270e7a70fa81a5935b72eacbe29" args="" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;typename T, K_UINT_32 BEG, bool OQ = false, bool OVR = false, bool DBG = true&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="a00013.html">Matrix</a> <a class="el" href="a00010.html">Kalman::EKFilter</a>&lt; T, BEG, OQ, OVR, DBG &gt;::<a class="el" href="a00010.html#7fc56270e7a70fa81a5935b72eacbe29">A</a><code> [protected]</code>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
A jacobian matrix. 
<p>
This is an <em>n</em> by <em>n</em> jacobian matrix of partial derivatives, defined as follow : <p class="formulaDsp">
<img class="formulaDsp" alt="\[ A_{[i,j]} = \frac{\partial f_{[i]}}{\partial x_{[j]}} \]" src="form_21.png">
<p>
 Derived classes should modify it only through <code><a class="el" href="a00010.html#518036f135c91caa3c3d76b172775485">makeBaseA()</a></code> for the constant part and <code><a class="el" href="a00010.html#fb6168f2a88d8674d1cfa349bd78263b">makeA()</a></code> for the variable part.     </td>
  </tr>
</table>
<a class="anchor" name="61e9c06ea9a85a5088a499df6458d276"></a><!-- doxytag: member="Kalman::EKFilter::W" ref="61e9c06ea9a85a5088a499df6458d276" args="" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;typename T, K_UINT_32 BEG, bool OQ = false, bool OVR = false, bool DBG = true&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="a00013.html">Matrix</a> <a class="el" href="a00010.html">Kalman::EKFilter</a>&lt; T, BEG, OQ, OVR, DBG &gt;::<a class="el" href="a00010.html#61e9c06ea9a85a5088a499df6458d276">W</a><code> [protected]</code>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
A jacobian matrix. 
<p>
This is an <em>n</em> by <em>nw</em> jacobian matrix of partial derivatives, defined as follow : <p class="formulaDsp">
<img class="formulaDsp" alt="\[ W_{[i,j]} = \frac{\partial f_{[i]}}{\partial w_{[j]}} \]" src="form_22.png">
<p>
 Derived classes should modify it only through <code><a class="el" href="a00010.html#fee4e2d5e2ee0e0b384328ef4b5acd10">makeBaseW()</a></code> for the constant part and <code><a class="el" href="a00010.html#f1741e4ff0f84763d7207d4f418b0efb">makeW()</a></code> for the variable part.     </td>
  </tr>
</table>
<a class="anchor" name="f09564c9ca56850d4cd6b3319e541aee"></a><!-- doxytag: member="Kalman::EKFilter::Q" ref="f09564c9ca56850d4cd6b3319e541aee" args="" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;typename T, K_UINT_32 BEG, bool OQ = false, bool OVR = false, bool DBG = true&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="a00013.html">Matrix</a> <a class="el" href="a00010.html">Kalman::EKFilter</a>&lt; T, BEG, OQ, OVR, DBG &gt;::<a class="el" href="a00010.html#f09564c9ca56850d4cd6b3319e541aee">Q</a><code> [protected]</code>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Process noise covariance matrix. 
<p>
This is the <em>nw</em> by <em>nw</em> covariance matrix of <em>w</em>, that is : <p class="formulaDsp">
<img class="formulaDsp" alt="\[ Q = E\left( w w^T \right) \]" src="form_54.png">
<p>
 Derived classes should modify it only through <code><a class="el" href="a00010.html#5df090d462672680b2727f9d777ecf38">makeBaseQ()</a></code> for the constant part and <code><a class="el" href="a00010.html#a0e7ca750254434464c222094dbd14b2">makeQ()</a></code> for the variable part. If <em>Q</em> is always diagonal, then you should turn on the <code>OQ</code> optimization.     </td>
  </tr>
</table>
<a class="anchor" name="c1d9f50f86825a1a2302ec2449c17196"></a><!-- doxytag: member="Kalman::EKFilter::H" ref="c1d9f50f86825a1a2302ec2449c17196" args="" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;typename T, K_UINT_32 BEG, bool OQ = false, bool OVR = false, bool DBG = true&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="a00013.html">Matrix</a> <a class="el" href="a00010.html">Kalman::EKFilter</a>&lt; T, BEG, OQ, OVR, DBG &gt;::<a class="el" href="a00010.html#c1d9f50f86825a1a2302ec2449c17196">H</a><code> [protected]</code>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
A jacobian matrix. 
<p>
This is an <em>m</em> by <em>n</em> jacobian matrix of partial derivatives, defined as follow : <p class="formulaDsp">
<img class="formulaDsp" alt="\[ H_{[i,j]} = \frac{\partial h_{[i]}}{\partial x_{[j]}} \]" src="form_23.png">
<p>
 Derived classes should modify it only through <code><a class="el" href="a00010.html#82beae7bd03ecf043dc2879020211a01">makeBaseH()</a></code> for the constant part and <code><a class="el" href="a00010.html#0d915861910cdc17361f829d486de6a0">makeH()</a></code> for the variable part.     </td>
  </tr>
</table>
<a class="anchor" name="5206560a306a2e085a437fd258eb57ce"></a><!-- doxytag: member="Kalman::EKFilter::V" ref="5206560a306a2e085a437fd258eb57ce" args="" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;typename T, K_UINT_32 BEG, bool OQ = false, bool OVR = false, bool DBG = true&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="a00013.html">Matrix</a> <a class="el" href="a00010.html">Kalman::EKFilter</a>&lt; T, BEG, OQ, OVR, DBG &gt;::<a class="el" href="a00010.html#5206560a306a2e085a437fd258eb57ce">V</a><code> [protected]</code>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
A jacobian matrix. 
<p>
This is an <em>m</em> by <em>nv</em> jacobian matrix of partial derivatives, defined as follow : <p class="formulaDsp">
<img class="formulaDsp" alt="\[ V_{[i,j]} = \frac{\partial h_{[i]}}{\partial v_{[j]}} \]" src="form_24.png">
<p>
 Derived classes should modify it only through <code><a class="el" href="a00010.html#328205b3d3440b18cdc7701ca961d40d">makeBaseV()</a></code> for the constant part and <code><a class="el" href="a00010.html#67f3a2a311f16ab10ce684dacc46b4ce">makeV()</a></code> for the variable part. If both V and R are always diagonal, then you should turn on the <code>OVR</code> optimization.     </td>
  </tr>
</table>
<a class="anchor" name="e1e1d3d40573127e9ee0480caf1283d6"></a><!-- doxytag: member="Kalman::EKFilter::R" ref="e1e1d3d40573127e9ee0480caf1283d6" args="" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;typename T, K_UINT_32 BEG, bool OQ = false, bool OVR = false, bool DBG = true&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="a00013.html">Matrix</a> <a class="el" href="a00010.html">Kalman::EKFilter</a>&lt; T, BEG, OQ, OVR, DBG &gt;::<a class="el" href="a00010.html#e1e1d3d40573127e9ee0480caf1283d6">R</a><code> [protected]</code>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Measurement noise covariance matrix. 
<p>
This is the <em>nv</em> by <em>nv</em> covariance matrix of <em>v</em>, that is : <p class="formulaDsp">
<img class="formulaDsp" alt="\[ R = E\left( v v^T \right) \]" src="form_55.png">
<p>
 Derived classes should modify it only through <code><a class="el" href="a00010.html#48cf2273a4cdeee90fedc917a3c509bb">makeBaseR()</a></code> for the constant part and <code><a class="el" href="a00010.html#c8ed8c9c7a53f9f4108f64e5710ad926">makeR()</a></code> for the variable part. If both <em>V</em> and <em>R</em> are always diagonal, then you should turn on the <code>OVR</code> optimization.     </td>
  </tr>
</table>
<hr>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="a00032.html">ekfilter.hpp</a><li><a class="el" href="a00033.html">ekfilter_impl.hpp</a></ul>
<hr size="1"><address style="align: right;"><small>Generated on Sat Jan 28 21:02:01 2006 for KFilter by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.5 </small></address>
</body>
</html>
