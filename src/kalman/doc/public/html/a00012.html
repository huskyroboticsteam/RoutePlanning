<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>KFilter: Kalman::KFilter&lt; T, BEG, OQ, OVR, DBG &gt; Class Template Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.5 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li id="current"><a href="annotated.html"><span>Classes</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li><a href="dirs.html"><span>Directories</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
  </ul></div>
<div class="tabs">
  <ul>
    <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
    <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
    <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
  </ul></div>
<div class="nav">
<a class="el" href="a00029.html">Kalman</a>::<a class="el" href="a00012.html">KFilter</a></div>
<h1>Kalman::KFilter&lt; T, BEG, OQ, OVR, DBG &gt; Class Template Reference</h1><!-- doxytag: class="Kalman::KFilter" --><!-- doxytag: inherits="Kalman::EKFilter" -->Generic Linear <a class="el" href="a00029.html">Kalman</a> Filter template base class.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;<a class="el" href="a00034.html">kfilter.hpp</a>&gt;</code>
<p>
<p>Inheritance diagram for Kalman::KFilter&lt; T, BEG, OQ, OVR, DBG &gt;:
<p><center><img src="a00012.png" usemap="#Kalman::KFilter< T, BEG, OQ, OVR, DBG >_map" border="0" alt=""></center>
<map name="Kalman::KFilter< T, BEG, OQ, OVR, DBG >_map">
<area href="a00010.html" alt="Kalman::EKFilter< T, BEG, OQ, OVR, DBG >" shape="rect" coords="0,0,269,24">
</map>
Collaboration diagram for Kalman::KFilter&lt; T, BEG, OQ, OVR, DBG &gt;:<p><center><img src="a00064.png" border="0" usemap="#a00065" alt="Collaboration graph"></center>
<map name="a00065">
<area href="a00010.html" shape="rect" coords="88,269,365,293" alt="">
<area href="a00015.html" shape="rect" coords="7,19,215,43" alt="">
<area href="a00013.html" shape="rect" coords="238,19,446,43" alt="">
</map>
<center><font size="2">[<a href="graph_legend.html">legend</a>]</font></center><a href="a00002.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Types</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="599dcce2998a6b40b1e38e8c6006cb0a"></a><!-- doxytag: member="Kalman::KFilter::type" ref="599dcce2998a6b40b1e38e8c6006cb0a" args="" -->
typedef T&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00010.html#599dcce2998a6b40b1e38e8c6006cb0a">type</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Type of objects contained in matrices and vectors. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="57dea6f5039281b7fee517fc43bf3110"></a><!-- doxytag: member="Kalman::KFilter::Vector" ref="57dea6f5039281b7fee517fc43bf3110" args="" -->
typedef <a class="el" href="a00015.html">KVector</a>&lt; T, BEG, DBG &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00010.html#57dea6f5039281b7fee517fc43bf3110">Vector</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Vector type. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="f53df0293e169f562bc1d9a20e1d2589"></a><!-- doxytag: member="Kalman::KFilter::Matrix" ref="f53df0293e169f562bc1d9a20e1d2589" args="" -->
typedef <a class="el" href="a00013.html">KMatrix</a>&lt; T, BEG, DBG &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00010.html#f53df0293e169f562bc1d9a20e1d2589">Matrix</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Matrix type. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom">{ <a class="el" href="a00010.html#dca29a1140aadadfd92b34a02fa516ef63a08f52a29e0f7a1f987f4495164ab0">beg</a> =  BEG
 }</td></tr>

<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="44da30030736cb21c77e4d8f43c9afde"></a><!-- doxytag: member="Kalman::KFilter::~KFilter" ref="44da30030736cb21c77e4d8f43c9afde" args="()=0" -->
virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00012.html#44da30030736cb21c77e4d8f43c9afde">~KFilter</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Virtual destructor. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00010.html#50886bc1066141f71bd94296cd8ad676">init</a> (<a class="el" href="a00010.html#57dea6f5039281b7fee517fc43bf3110">Vector</a> &amp;x_, <a class="el" href="a00010.html#f53df0293e169f562bc1d9a20e1d2589">Matrix</a> &amp;P_)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets initial conditions for the Kalman Filter.  <a href="#50886bc1066141f71bd94296cd8ad676"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Dimension Accessor Functions</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ed9480862d6cb9be0264c0aad8862926"></a><!-- doxytag: member="Kalman::KFilter::getSizeX" ref="ed9480862d6cb9be0264c0aad8862926" args="() const " -->
<a class="el" href="a00029.html#52dcd207f3e190d4f374ce16bdcd153f">K_UINT_32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00010.html#ed9480862d6cb9be0264c0aad8862926">getSizeX</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the size of the state vector. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="c3b4e51482d1215ec0ad65346e0f33c2"></a><!-- doxytag: member="Kalman::KFilter::getSizeU" ref="c3b4e51482d1215ec0ad65346e0f33c2" args="() const " -->
<a class="el" href="a00029.html#52dcd207f3e190d4f374ce16bdcd153f">K_UINT_32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00010.html#c3b4e51482d1215ec0ad65346e0f33c2">getSizeU</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the size of the input vector. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a37b16daac459e871fe3c477f90b72af"></a><!-- doxytag: member="Kalman::KFilter::getSizeW" ref="a37b16daac459e871fe3c477f90b72af" args="() const " -->
<a class="el" href="a00029.html#52dcd207f3e190d4f374ce16bdcd153f">K_UINT_32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00010.html#a37b16daac459e871fe3c477f90b72af">getSizeW</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the size of the process noise vector. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="e986404794059dfb8cd93289ca5ba499"></a><!-- doxytag: member="Kalman::KFilter::getSizeZ" ref="e986404794059dfb8cd93289ca5ba499" args="() const " -->
<a class="el" href="a00029.html#52dcd207f3e190d4f374ce16bdcd153f">K_UINT_32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00010.html#e986404794059dfb8cd93289ca5ba499">getSizeZ</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the size of the measurement vector. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="5598ed90355e06a068e4fa6aa944243c"></a><!-- doxytag: member="Kalman::KFilter::getSizeV" ref="5598ed90355e06a068e4fa6aa944243c" args="() const " -->
<a class="el" href="a00029.html#52dcd207f3e190d4f374ce16bdcd153f">K_UINT_32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00010.html#5598ed90355e06a068e4fa6aa944243c">getSizeV</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the size of the measurement noise vector. <br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Resizing Functions</div></td></tr>
<tr><td colspan="2"><div class="groupText">These functions allow to change the dimensions of all matrices and vectors, thus implementing a Variable-Dimension Extended Kalman Filter. They do nothing if the new size is the same as the old one. <dl compact><dt><b>Warning:</b></dt><dd><code>setDim()</code> (or the five <code>setSize</code> functions) <b>must</b> be called <b>before</b> any other function, or else, matrices and vectors will not have their memory allocated. </dd></dl>
<br><br></div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00010.html#23101e8b17b27d57b1bf2668904bf4ec">setDim</a> (<a class="el" href="a00029.html#52dcd207f3e190d4f374ce16bdcd153f">K_UINT_32</a> n_, <a class="el" href="a00029.html#52dcd207f3e190d4f374ce16bdcd153f">K_UINT_32</a> nu_, <a class="el" href="a00029.html#52dcd207f3e190d4f374ce16bdcd153f">K_UINT_32</a> nw_, <a class="el" href="a00029.html#52dcd207f3e190d4f374ce16bdcd153f">K_UINT_32</a> m_, <a class="el" href="a00029.html#52dcd207f3e190d4f374ce16bdcd153f">K_UINT_32</a> nv_)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets all dimensions at once.  <a href="#23101e8b17b27d57b1bf2668904bf4ec"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00010.html#5d3999b77ab3165b6c2b0b8b8f192139">setSizeX</a> (<a class="el" href="a00029.html#52dcd207f3e190d4f374ce16bdcd153f">K_UINT_32</a> n_)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the size of the state vector.  <a href="#5d3999b77ab3165b6c2b0b8b8f192139"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="5fadf1a13e6030168d073ef4fa7d162f"></a><!-- doxytag: member="Kalman::KFilter::setSizeU" ref="5fadf1a13e6030168d073ef4fa7d162f" args="(K_UINT_32 nu_)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00010.html#5fadf1a13e6030168d073ef4fa7d162f">setSizeU</a> (<a class="el" href="a00029.html#52dcd207f3e190d4f374ce16bdcd153f">K_UINT_32</a> nu_)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the size of the input vector. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00010.html#ef9e77d7e4d0e9c963456455ba5b85cc">setSizeW</a> (<a class="el" href="a00029.html#52dcd207f3e190d4f374ce16bdcd153f">K_UINT_32</a> nw_)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the size of the process noise vector.  <a href="#ef9e77d7e4d0e9c963456455ba5b85cc"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ef7c6328d66fc66f3f43b5bb24c67ff5"></a><!-- doxytag: member="Kalman::KFilter::setSizeZ" ref="ef7c6328d66fc66f3f43b5bb24c67ff5" args="(K_UINT_32 m_)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00010.html#ef7c6328d66fc66f3f43b5bb24c67ff5">setSizeZ</a> (<a class="el" href="a00029.html#52dcd207f3e190d4f374ce16bdcd153f">K_UINT_32</a> m_)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the size of the measurement vector. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="3fd4fa1f9458c5221eabdd23880bce45"></a><!-- doxytag: member="Kalman::KFilter::setSizeV" ref="3fd4fa1f9458c5221eabdd23880bce45" args="(K_UINT_32 nv_)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00010.html#3fd4fa1f9458c5221eabdd23880bce45">setSizeV</a> (<a class="el" href="a00029.html#52dcd207f3e190d4f374ce16bdcd153f">K_UINT_32</a> nv_)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the size of the measurement noise vector. <br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Kalman Filter Functions</div></td></tr>
<tr><td colspan="2"><div class="groupText">These functions allow to get the results from the Kalman filtering algorithm. Before any of these can be called, all dimensions must have been set properly at least once and <code>init()</code> must have been called, also at least once. Each time the user want to resize some vectors, the corresponding resizing functions must be called again before being able to call one of the functions in this section. <code>init()</code> must also be called again if <em>n</em> or <em>nw</em> has changed. <code>init()</code> can also be called solely to reset the filter. <br><br></div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00010.html#9ce43496cd9547c192ba45ffd3e93d13">step</a> (<a class="el" href="a00010.html#57dea6f5039281b7fee517fc43bf3110">Vector</a> &amp;u_, const <a class="el" href="a00010.html#57dea6f5039281b7fee517fc43bf3110">Vector</a> &amp;z_)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Makes one prediction-correction step.  <a href="#9ce43496cd9547c192ba45ffd3e93d13"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00010.html#fd603471b0a9b0c188fc5ac00b993752">timeUpdateStep</a> (<a class="el" href="a00010.html#57dea6f5039281b7fee517fc43bf3110">Vector</a> &amp;u_)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Makes one prediction step.  <a href="#fd603471b0a9b0c188fc5ac00b993752"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00010.html#68983cf3280fc4b7e99ffda7b76bb684">measureUpdateStep</a> (const <a class="el" href="a00010.html#57dea6f5039281b7fee517fc43bf3110">Vector</a> &amp;z_)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Makes one correction step.  <a href="#68983cf3280fc4b7e99ffda7b76bb684"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const <a class="el" href="a00010.html#57dea6f5039281b7fee517fc43bf3110">Vector</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00010.html#fc92e7081f91b62523576c1b3536e4b3">predict</a> (<a class="el" href="a00010.html#57dea6f5039281b7fee517fc43bf3110">Vector</a> &amp;u_)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the predicted state vector (<em>a priori</em> state estimate).  <a href="#fc92e7081f91b62523576c1b3536e4b3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const <a class="el" href="a00010.html#57dea6f5039281b7fee517fc43bf3110">Vector</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00010.html#8e2a9f50c3301dc17bd68c58396369a5">simulate</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the predicted measurement vector.  <a href="#8e2a9f50c3301dc17bd68c58396369a5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="13d45fb54591fd367613a88b03e33dd2"></a><!-- doxytag: member="Kalman::KFilter::getX" ref="13d45fb54591fd367613a88b03e33dd2" args="() const " -->
const <a class="el" href="a00010.html#57dea6f5039281b7fee517fc43bf3110">Vector</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00010.html#13d45fb54591fd367613a88b03e33dd2">getX</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the corrected state (<em>a posteriori</em> state estimate). <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const <a class="el" href="a00010.html#f53df0293e169f562bc1d9a20e1d2589">Matrix</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00010.html#ac0985755b9fbeb6330aef0c34546a91">calculateP</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the <em>a posteriori</em> error covariance estimate matrix.  <a href="#ac0985755b9fbeb6330aef0c34546a91"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="f75bee65167754eb741cf0e34ba38ca7"></a><!-- doxytag: member="Kalman::KFilter::makeBaseB" ref="f75bee65167754eb741cf0e34ba38ca7" args="()" -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00012.html#f75bee65167754eb741cf0e34ba38ca7">makeBaseB</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Virtual pre-creator of <em>B</em>. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="1001e8b133b9a40375a960f13176a008"></a><!-- doxytag: member="Kalman::KFilter::makeB" ref="1001e8b133b9a40375a960f13176a008" args="()" -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00012.html#1001e8b133b9a40375a960f13176a008">makeB</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Virtual creator of <em>B</em>. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00010.html#bfca7d629f94d7954e48597108e0ba21">NoModification</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allows optimizations on some calculations.  <a href="#bfca7d629f94d7954e48597108e0ba21"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Matrix Pre-Creators</div></td></tr>
<tr><td colspan="2"><div class="groupText">Theses functions have been designed to be overridden by derived classes if necessary. Their role is to fill in the parts of the Kalman matrices that don't change between iterations. That is to say, these functions should only set constant values inside matrices that don't depend on <em>x</em> or <em>u</em>.<p>
They will all be called at least once, before the calls to their corresponding matrix (not pre-) creators. In fact, they are called once per resize (not necessarily at the moment of the resize though), including while the matrices are first allocated.<p>
<dl compact><dt><b>Note:</b></dt><dd>Matrices have already been properly resized before these functions are called, so no further resizing is or should be necessary. <p>
If a matrix pre-creator is overridden, but it does not modify in any way the matrix in certain execution paths, then the function <code>NoModification()</code> should be called in each of those execution paths so that the filter can optimize away some calculations. The default versions of the matrix pre-creators only call <code>NoModification()</code> in their bodies. </dd></dl>
<dl compact><dt><b>Warning:</b></dt><dd>Each matrix pre-creator cannot suppose that any other matrix pre-creator will be called before or after it. </dd></dl>
<br><br></div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="518036f135c91caa3c3d76b172775485"></a><!-- doxytag: member="Kalman::KFilter::makeBaseA" ref="518036f135c91caa3c3d76b172775485" args="()" -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00010.html#518036f135c91caa3c3d76b172775485">makeBaseA</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Virtual pre-creator of <em>A</em>. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="fee4e2d5e2ee0e0b384328ef4b5acd10"></a><!-- doxytag: member="Kalman::KFilter::makeBaseW" ref="fee4e2d5e2ee0e0b384328ef4b5acd10" args="()" -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00010.html#fee4e2d5e2ee0e0b384328ef4b5acd10">makeBaseW</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Virtual pre-creator of <em>W</em>. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00010.html#5df090d462672680b2727f9d777ecf38">makeBaseQ</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Virtual pre-creator of <em>Q</em>.  <a href="#5df090d462672680b2727f9d777ecf38"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="82beae7bd03ecf043dc2879020211a01"></a><!-- doxytag: member="Kalman::KFilter::makeBaseH" ref="82beae7bd03ecf043dc2879020211a01" args="()" -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00010.html#82beae7bd03ecf043dc2879020211a01">makeBaseH</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Virtual pre-creator of <em>H</em>. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00010.html#328205b3d3440b18cdc7701ca961d40d">makeBaseV</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Virtual pre-creator of <em>V</em>.  <a href="#328205b3d3440b18cdc7701ca961d40d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00010.html#48cf2273a4cdeee90fedc917a3c509bb">makeBaseR</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Virtual pre-creator of <em>R</em>.  <a href="#48cf2273a4cdeee90fedc917a3c509bb"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Matrix Creators</div></td></tr>
<tr><td colspan="2"><div class="groupText">Theses functions have been designed to be overridden by derived classes if necessary. Their role is to fill in the parts of the Kalman matrices that change between iterations. That is to say, these functions should set values inside matrices that depend on <em>x</em> or <em>u</em>.<p>
These functions can suppose that their corresponding matrix pre-creator has been called at least once before. Also, <code>makeA()</code>, <code>makeW()</code>, <code>makeQ()</code> and <code>makeProcess()</code> can suppose that <code>makeCommonProcess()</code> is called every time just before it being called. Same thing for <code>makeH()</code>, <code>makeV()</code>, <code>makeR()</code> and <code>makeMeasure()</code> about <code>makeCommonMeasure()</code>.<p>
<dl compact><dt><b>Note:</b></dt><dd>Matrices have already been properly resized before these functions are called, so no further resizing is or should be necessary. <p>
If a matrix creator is overridden, but it does not modify in any way the matrix in certain execution paths, then the function <code>NoModification()</code> should be called in each of those execution paths so that the filter can optimize away some calculations. The default versions of the matrix creators only call <code>NoModification()</code> in their bodies. </dd></dl>
<dl compact><dt><b>Warning:</b></dt><dd>Each matrix creator cannot suppose that any other matrix creator will be called before or after it. One thing is sure : <code>makeCommon*</code>() is called first, then some of <code>make*</code>() and finally, <code>makeProcess()</code> or <code>makeMeasure()</code>. <p>
These functions can access <em>x</em> and <em>u</em> in read-only mode, except makeProcess(), which must modify <em>x</em>. </dd></dl>
<br><br></div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00010.html#00af959e9f2bb73e4a5ccecafd74617d">makeCommonProcess</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Optional function used to precalculate common values for process.  <a href="#00af959e9f2bb73e4a5ccecafd74617d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="fb6168f2a88d8674d1cfa349bd78263b"></a><!-- doxytag: member="Kalman::KFilter::makeA" ref="fb6168f2a88d8674d1cfa349bd78263b" args="()" -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00010.html#fb6168f2a88d8674d1cfa349bd78263b">makeA</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Virtual creator of <em>A</em>. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="f1741e4ff0f84763d7207d4f418b0efb"></a><!-- doxytag: member="Kalman::KFilter::makeW" ref="f1741e4ff0f84763d7207d4f418b0efb" args="()" -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00010.html#f1741e4ff0f84763d7207d4f418b0efb">makeW</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Virtual creator of <em>W</em>. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00010.html#a0e7ca750254434464c222094dbd14b2">makeQ</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Virtual creator of <em>Q</em>.  <a href="#a0e7ca750254434464c222094dbd14b2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00010.html#b2368423153d84f471a49873224958ab">makeCommonMeasure</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Optional function used to precalculate common values for measurement.  <a href="#b2368423153d84f471a49873224958ab"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="0d915861910cdc17361f829d486de6a0"></a><!-- doxytag: member="Kalman::KFilter::makeH" ref="0d915861910cdc17361f829d486de6a0" args="()" -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00010.html#0d915861910cdc17361f829d486de6a0">makeH</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Virtual creator of <em>H</em>. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00010.html#67f3a2a311f16ab10ce684dacc46b4ce">makeV</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Virtual creator of <em>V</em>.  <a href="#67f3a2a311f16ab10ce684dacc46b4ce"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00010.html#c8ed8c9c7a53f9f4108f64e5710ad926">makeR</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Virtual creator of <em>R</em>.  <a href="#c8ed8c9c7a53f9f4108f64e5710ad926"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00010.html#df3cc66147296230b4e8da64460426be">makeDZ</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Hook-up function to modify innovation vector.  <a href="#df3cc66147296230b4e8da64460426be"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="9d5ed678fe57bcca610140957afab571"></a><!-- doxytag: member="Kalman::KFilter::B" ref="9d5ed678fe57bcca610140957afab571" args="" -->
<a class="el" href="a00010.html#f53df0293e169f562bc1d9a20e1d2589">Matrix</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00012.html#9d5ed678fe57bcca610140957afab571">B</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Input matrix. <br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Kalman Vectors and Matrices</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="a00010.html#57dea6f5039281b7fee517fc43bf3110">Vector</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00010.html#9dd4e461268c8034f5c8564e155c67a6">x</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Corrected state vector.  <a href="#9dd4e461268c8034f5c8564e155c67a6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="a00010.html#57dea6f5039281b7fee517fc43bf3110">Vector</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00010.html#7b774effe4a349c6dd82ad4f4f21d34c">u</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Input vector.  <a href="#7b774effe4a349c6dd82ad4f4f21d34c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="a00010.html#57dea6f5039281b7fee517fc43bf3110">Vector</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00010.html#fbade9e36a3f36d3d676c1b808451dd7">z</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Predicted measurement vector.  <a href="#fbade9e36a3f36d3d676c1b808451dd7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="a00010.html#57dea6f5039281b7fee517fc43bf3110">Vector</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00010.html#0de7b6a61a70688b26e6eeb3113531a3">dz</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Innovation vector.  <a href="#0de7b6a61a70688b26e6eeb3113531a3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="a00010.html#f53df0293e169f562bc1d9a20e1d2589">Matrix</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00010.html#7fc56270e7a70fa81a5935b72eacbe29">A</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A jacobian matrix.  <a href="#7fc56270e7a70fa81a5935b72eacbe29"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="a00010.html#f53df0293e169f562bc1d9a20e1d2589">Matrix</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00010.html#61e9c06ea9a85a5088a499df6458d276">W</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A jacobian matrix.  <a href="#61e9c06ea9a85a5088a499df6458d276"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="a00010.html#f53df0293e169f562bc1d9a20e1d2589">Matrix</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00010.html#f09564c9ca56850d4cd6b3319e541aee">Q</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Process noise covariance matrix.  <a href="#f09564c9ca56850d4cd6b3319e541aee"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="a00010.html#f53df0293e169f562bc1d9a20e1d2589">Matrix</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00010.html#c1d9f50f86825a1a2302ec2449c17196">H</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A jacobian matrix.  <a href="#c1d9f50f86825a1a2302ec2449c17196"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="a00010.html#f53df0293e169f562bc1d9a20e1d2589">Matrix</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00010.html#5206560a306a2e085a437fd258eb57ce">V</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A jacobian matrix.  <a href="#5206560a306a2e085a437fd258eb57ce"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="a00010.html#f53df0293e169f562bc1d9a20e1d2589">Matrix</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00010.html#e1e1d3d40573127e9ee0480caf1283d6">R</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Measurement noise covariance matrix.  <a href="#e1e1d3d40573127e9ee0480caf1283d6"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Kalman Dimensions</div></td></tr>
<tr><td colspan="2"><div class="groupText"><dl compact><dt><b>Warning:</b></dt><dd>These values, which are accessible to derived classes, are read-only. The derived classes should use the resizing functions to modify vector and matrix dimensions. </dd></dl>
<br><br></div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="7b8b965ad4bca0e41ab51de7b31363a1"></a><!-- doxytag: member="Kalman::KFilter::n" ref="7b8b965ad4bca0e41ab51de7b31363a1" args="" -->
<a class="el" href="a00029.html#52dcd207f3e190d4f374ce16bdcd153f">K_UINT_32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00010.html#7b8b965ad4bca0e41ab51de7b31363a1">n</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Size of the state vector. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="0288bde0c2d593f2b5766f61b826a650"></a><!-- doxytag: member="Kalman::KFilter::nu" ref="0288bde0c2d593f2b5766f61b826a650" args="" -->
<a class="el" href="a00029.html#52dcd207f3e190d4f374ce16bdcd153f">K_UINT_32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00010.html#0288bde0c2d593f2b5766f61b826a650">nu</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Size of the input vector. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="6a814fdcdf0ea6037af96b3de6f17750"></a><!-- doxytag: member="Kalman::KFilter::nw" ref="6a814fdcdf0ea6037af96b3de6f17750" args="" -->
<a class="el" href="a00029.html#52dcd207f3e190d4f374ce16bdcd153f">K_UINT_32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00010.html#6a814fdcdf0ea6037af96b3de6f17750">nw</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Size of the process noise vector. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="6f8f57715090da2632453988d9a1501b"></a><!-- doxytag: member="Kalman::KFilter::m" ref="6f8f57715090da2632453988d9a1501b" args="" -->
<a class="el" href="a00029.html#52dcd207f3e190d4f374ce16bdcd153f">K_UINT_32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00010.html#6f8f57715090da2632453988d9a1501b">m</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Size of the measurement vector. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="f9eab7a52fbda6f4788f438ba1a8da94"></a><!-- doxytag: member="Kalman::KFilter::nv" ref="f9eab7a52fbda6f4788f438ba1a8da94" args="" -->
<a class="el" href="a00029.html#52dcd207f3e190d4f374ce16bdcd153f">K_UINT_32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00010.html#f9eab7a52fbda6f4788f438ba1a8da94">nv</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Size of the measurement noise vector. <br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
<h3>template&lt;typename T, K_UINT_32 BEG, bool OQ = false, bool OVR = false, bool DBG = true&gt;<br>
 class Kalman::KFilter&lt; T, BEG, OQ, OVR, DBG &gt;</h3>

Generic Linear <a class="el" href="a00029.html">Kalman</a> Filter template base class. 
<p>
<dl compact><dt><b>Usage</b></dt><dd>This class is derived from <code><a class="el" href="a00010.html">EKFilter</a></code>. You should really read all the documentation of <code><a class="el" href="a00010.html">EKFilter</a></code> before reading this. <br>
 This class implements a Variable-Dimension Linear <a class="el" href="a00029.html">Kalman</a> Filter based on the <code><a class="el" href="a00010.html">EKFilter</a></code> template class.</dd></dl>
<dl compact><dt><b>Notation</b></dt><dd>Assume a state vector <img class="formulaInl" alt="$ x $" src="form_37.png"> (to estimate) and a linear process function <img class="formulaInl" alt="$ f $" src="form_2.png"> (to model) that describes the evolution of this state through time, that is : <p class="formulaDsp">
<img class="formulaDsp" alt="\[ x_k = f \left( x_{k-1}, u_{k-1}, w_{k-1} \right) = A x_{k-1} + B u_{k-1} + W w_{k-1} \]" src="form_70.png">
<p>
 where <img class="formulaInl" alt="$ u $" src="form_14.png"> is the (known) input vector fed to the process and <img class="formulaInl" alt="$ w $" src="form_4.png"> is the (unknown) process noise vector due to uncertainty and process modeling errors. Further suppose that the (known) process noise covariance matrix is : <p class="formulaDsp">
<img class="formulaDsp" alt="\[ Q = E \left( w w^T \right) \]" src="form_39.png">
<p>
 Now, let's assume a (known) measurement vector <img class="formulaInl" alt="$ z $" src="form_40.png"> , which depends on the current state <img class="formulaInl" alt="$ x $" src="form_37.png"> in the form of a linear function <img class="formulaInl" alt="$ h $" src="form_36.png"> (to model) : <p class="formulaDsp">
<img class="formulaDsp" alt="\[ z_k = h \left( x_k, v_k \right) = H x_k + V v_k \]" src="form_71.png">
<p>
 where <img class="formulaInl" alt="$ v $" src="form_7.png"> is the (unknown) measurement noise vector with a (known) covariance matrix : <p class="formulaDsp">
<img class="formulaDsp" alt="\[ R = E \left( v v^T \right) \]" src="form_42.png">
<p>
 Suppose that we have an estimate of the previous state <img class="formulaInl" alt="$ \hat{x}_{k-1} $" src="form_43.png"> , called a corrected state or an <em>a posteriori</em> state estimate. We can build a predicted state (also called an <em>a priori</em> state estimate) by using <img class="formulaInl" alt="$ f $" src="form_2.png"> : <p class="formulaDsp">
<img class="formulaDsp" alt="\[ \tilde{x}_k = f \left( \hat{x}_{k-1}, u_{k-1}, 0 \right) = A \hat{x}_{k-1} + B u_{k-1} \]" src="form_72.png">
<p>
 since the input is known and the process noise, unknown. With this predicted state, we can get a predicted measurement vector by using <img class="formulaInl" alt="$ h $" src="form_36.png"> : <p class="formulaDsp">
<img class="formulaDsp" alt="\[ \tilde{z}_k = h \left( \tilde{x}_k, 0 \right) = H \tilde{x}_k \]" src="form_73.png">
<p>
 since the measurement noise is unknown.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>In this class, <code>makeProcess()</code> and <code>makeMeasure()</code> have already been overridden, and cannot be ovverridden again. However, there is a new matrix to create : <em>B</em>. This means there are two new virtual functions that can be overridden : <code><a class="el" href="a00012.html#f75bee65167754eb741cf0e34ba38ca7">makeBaseB()</a></code> and <code><a class="el" href="a00012.html#1001e8b133b9a40375a960f13176a008">makeB()</a></code>. </dd></dl>
<dl compact><dt><b>See also:</b></dt><dd><code><a class="el" href="a00010.html">EKFilter</a></code> </dd></dl>

<p>
<hr><h2>Member Enumeration Documentation</h2>
<a class="anchor" name="dca29a1140aadadfd92b34a02fa516ef"></a><!-- doxytag: member="Kalman::KFilter::@0" ref="dca29a1140aadadfd92b34a02fa516ef" args="" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;typename T, K_UINT_32 BEG, bool OQ = false, bool OVR = false, bool DBG = true&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top">anonymous enum<code> [inherited]</code>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<dl compact><dt><b>Enumerator: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" name="dca29a1140aadadfd92b34a02fa516ef63a08f52a29e0f7a1f987f4495164ab0"></a><!-- doxytag: member="beg" ref="dca29a1140aadadfd92b34a02fa516ef63a08f52a29e0f7a1f987f4495164ab0" args="" -->beg</em>&nbsp;</td><td>
Starting index of matrices and vectors. </td></tr>
</table>
</dl>
    </td>
  </tr>
</table>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="23101e8b17b27d57b1bf2668904bf4ec"></a><!-- doxytag: member="Kalman::KFilter::setDim" ref="23101e8b17b27d57b1bf2668904bf4ec" args="(K_UINT_32 n_, K_UINT_32 nu_, K_UINT_32 nw_, K_UINT_32 m_, K_UINT_32 nv_)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;typename T, K_UINT_32 BEG, bool OQ, bool OVR, bool DBG&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top">void <a class="el" href="a00010.html">Kalman::EKFilter</a>&lt; T, BEG, OQ, OVR, DBG &gt;::setDim           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="a00029.html#52dcd207f3e190d4f374ce16bdcd153f">K_UINT_32</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>n_</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="a00029.html#52dcd207f3e190d4f374ce16bdcd153f">K_UINT_32</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>nu_</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="a00029.html#52dcd207f3e190d4f374ce16bdcd153f">K_UINT_32</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>nw_</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="a00029.html#52dcd207f3e190d4f374ce16bdcd153f">K_UINT_32</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>m_</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="a00029.html#52dcd207f3e190d4f374ce16bdcd153f">K_UINT_32</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>nv_</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inherited]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Sets all dimensions at once. 
<p>
This function simply calls the <code>setSize*</code>() functions for <code>x, u, w, z, v</code> with the corresponding arguments. <dl compact><dt><b>Warning:</b></dt><dd>This function (or the corresponding five <code>setSize*</code>() functions) must be called before any other functions. <p>
<code><a class="el" href="a00010.html#50886bc1066141f71bd94296cd8ad676">init()</a></code> must always be called after this function and before any other non-dimensioning function. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="5d3999b77ab3165b6c2b0b8b8f192139"></a><!-- doxytag: member="Kalman::KFilter::setSizeX" ref="5d3999b77ab3165b6c2b0b8b8f192139" args="(K_UINT_32 n_)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;typename T, K_UINT_32 BEG, bool OQ, bool OVR, bool DBG&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top">void <a class="el" href="a00010.html">Kalman::EKFilter</a>&lt; T, BEG, OQ, OVR, DBG &gt;::setSizeX           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="a00029.html#52dcd207f3e190d4f374ce16bdcd153f">K_UINT_32</a>&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>n_</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inherited]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Sets the size of the state vector. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>n_</em>&nbsp;</td><td>New state vector size. Must not be 0. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Warning:</b></dt><dd><code><a class="el" href="a00010.html#50886bc1066141f71bd94296cd8ad676">init()</a></code> must always be called after this function and before any other non-dimensioning function. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ef9e77d7e4d0e9c963456455ba5b85cc"></a><!-- doxytag: member="Kalman::KFilter::setSizeW" ref="ef9e77d7e4d0e9c963456455ba5b85cc" args="(K_UINT_32 nw_)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;typename T, K_UINT_32 BEG, bool OQ, bool OVR, bool DBG&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top">void <a class="el" href="a00010.html">Kalman::EKFilter</a>&lt; T, BEG, OQ, OVR, DBG &gt;::setSizeW           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="a00029.html#52dcd207f3e190d4f374ce16bdcd153f">K_UINT_32</a>&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>nw_</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inherited]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Sets the size of the process noise vector. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>nw_</em>&nbsp;</td><td>New process noise vector size. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Warning:</b></dt><dd><code><a class="el" href="a00010.html#50886bc1066141f71bd94296cd8ad676">init()</a></code> must always be called after this function and before any other non-dimensioning function. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="50886bc1066141f71bd94296cd8ad676"></a><!-- doxytag: member="Kalman::KFilter::init" ref="50886bc1066141f71bd94296cd8ad676" args="(Vector &amp;x_, Matrix &amp;P_)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;typename T, K_UINT_32 BEG, bool OQ, bool OVR, bool DBG&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top">void <a class="el" href="a00010.html">Kalman::EKFilter</a>&lt; T, BEG, OQ, OVR, DBG &gt;::init           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="a00015.html">Vector</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>x_</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="a00013.html">Matrix</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>P_</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inherited]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Sets initial conditions for the Kalman Filter. 
<p>
This function allows to set an initial state estimate vector and an initial error covariance matrix estimate. This must be called at least once, after all dimensioning functions and before any other function. However, it can also be called anytime to reset or modify <em>x</em> or <em>P</em>. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>x_</em>&nbsp;</td><td>State vector estimate. Will be destroyed. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>P_</em>&nbsp;</td><td>Error covariance matrix estimate. Will be destroyed. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Warning:</b></dt><dd>If <code><a class="el" href="a00010.html#23101e8b17b27d57b1bf2668904bf4ec">setDim()</a></code>, <code><a class="el" href="a00010.html#5d3999b77ab3165b6c2b0b8b8f192139">setSizeX()</a></code> or <code><a class="el" href="a00010.html#ef9e77d7e4d0e9c963456455ba5b85cc">setSizeW()</a></code> is called, then <a class="el" href="a00010.html#50886bc1066141f71bd94296cd8ad676">init()</a> must be called again before any other non-dimensioning function. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="9ce43496cd9547c192ba45ffd3e93d13"></a><!-- doxytag: member="Kalman::KFilter::step" ref="9ce43496cd9547c192ba45ffd3e93d13" args="(Vector &amp;u_, const Vector &amp;z_)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;typename T, K_UINT_32 BEG, bool OQ, bool OVR, bool DBG&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top">void <a class="el" href="a00010.html">Kalman::EKFilter</a>&lt; T, BEG, OQ, OVR, DBG &gt;::step           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="a00015.html">Vector</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>u_</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const <a class="el" href="a00015.html">Vector</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>z_</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inherited]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Makes one prediction-correction step. 
<p>
This is the main <code><a class="el" href="a00010.html">EKFilter</a></code> function. First, it resizes any matrix who needs it. Then, it proceeds to the time update phase, using the input vector <code>u_</code>. This means that the following virtual functions <em>should be</em> called : <code><a class="el" href="a00010.html#00af959e9f2bb73e4a5ccecafd74617d">makeCommonProcess()</a></code>, <code><a class="el" href="a00010.html#fb6168f2a88d8674d1cfa349bd78263b">makeA()</a></code>, <code><a class="el" href="a00010.html#f1741e4ff0f84763d7207d4f418b0efb">makeW()</a></code>, <code><a class="el" href="a00010.html#a0e7ca750254434464c222094dbd14b2">makeQ()</a></code> and <code><a class="el" href="a00010.html#8caf231ab87d59bbc4b28ba840fc54d0">makeProcess()</a></code>. At this stage, <em>x</em> contains a current predicted state instead of an old corrected state. If <code>z_</code> is empty, that is, if there are no measures in this step, there is no correction and the function stops there. Else, the measure update phase begins. This means that the following virtual functions <em>should be</em> called : <code><a class="el" href="a00010.html#b2368423153d84f471a49873224958ab">makeCommonMeasure()</a></code>, <code>makeHImpl()</code>, <code>makeVImpl()</code>, <code>makeRImpl()</code>, <code><a class="el" href="a00010.html#f27fd54297218f5dad3981ea67b0e235">makeMeasure()</a></code> and <code><a class="el" href="a00010.html#df3cc66147296230b4e8da64460426be">makeDZ()</a></code>.After this phase, <em>x</em> contains the new corrected state. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>u_</em>&nbsp;</td><td>Input vector. Will <b>not</b> be destroyed. Can be empty. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>z_</em>&nbsp;</td><td>Measurement vector. Will <b>not</b> be destroyed. Can be empty. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="fd603471b0a9b0c188fc5ac00b993752"></a><!-- doxytag: member="Kalman::KFilter::timeUpdateStep" ref="fd603471b0a9b0c188fc5ac00b993752" args="(Vector &amp;u_)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;typename T, K_UINT_32 BEG, bool OQ, bool OVR, bool DBG&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top">void <a class="el" href="a00010.html">Kalman::EKFilter</a>&lt; T, BEG, OQ, OVR, DBG &gt;::timeUpdateStep           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="a00015.html">Vector</a> &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>u_</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inherited]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Makes one prediction step. 
<p>
This function first resizes any matrix who needs it. Then, it proceeds to the time update phase, using the input vector <code>u_</code>. This means that the following virtual functions <em>should be</em> called : <code><a class="el" href="a00010.html#00af959e9f2bb73e4a5ccecafd74617d">makeCommonProcess()</a></code>, <code><a class="el" href="a00010.html#fb6168f2a88d8674d1cfa349bd78263b">makeA()</a></code>, <code><a class="el" href="a00010.html#f1741e4ff0f84763d7207d4f418b0efb">makeW()</a></code>, <code><a class="el" href="a00010.html#a0e7ca750254434464c222094dbd14b2">makeQ()</a></code> and <code><a class="el" href="a00010.html#8caf231ab87d59bbc4b28ba840fc54d0">makeProcess()</a></code>. At this stage, <em>x</em> contains a current predicted state instead of an old corrected state. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>u_</em>&nbsp;</td><td>Input vector. Will <b>not</b> be destroyed. Can be empty. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="68983cf3280fc4b7e99ffda7b76bb684"></a><!-- doxytag: member="Kalman::KFilter::measureUpdateStep" ref="68983cf3280fc4b7e99ffda7b76bb684" args="(const Vector &amp;z_)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;typename T, K_UINT_32 BEG, bool OQ, bool OVR, bool DBG&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top">void <a class="el" href="a00010.html">Kalman::EKFilter</a>&lt; T, BEG, OQ, OVR, DBG &gt;::measureUpdateStep           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="a00015.html">Vector</a> &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>z_</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inherited]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Makes one correction step. 
<p>
First, this function resizes any matrix who needs it. If <code>z_</code> is empty, that is, if there are no measures in this step, there is no correction and the function stops there. Else, the measure update phase begins. This means that the following virtual functions <em>should be</em> called : <code><a class="el" href="a00010.html#b2368423153d84f471a49873224958ab">makeCommonMeasure()</a></code>, <code>makeHImpl()</code>, <code>makeVImpl()</code>, <code>makeRImpl()</code>, <code><a class="el" href="a00010.html#f27fd54297218f5dad3981ea67b0e235">makeMeasure()</a></code> and <code><a class="el" href="a00010.html#df3cc66147296230b4e8da64460426be">makeDZ()</a></code>.After this phase, <em>x</em> contains the new corrected state. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>z_</em>&nbsp;</td><td>Measurement vector. Will <b>not</b> be destroyed. Can be empty. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="fc92e7081f91b62523576c1b3536e4b3"></a><!-- doxytag: member="Kalman::KFilter::predict" ref="fc92e7081f91b62523576c1b3536e4b3" args="(Vector &amp;u_)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;typename T, K_UINT_32 BEG, bool OQ, bool OVR, bool DBG&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top">const <a class="el" href="a00010.html">EKFilter</a>&lt; T, BEG, OQ, OVR, DBG &gt;::<a class="el" href="a00010.html#57dea6f5039281b7fee517fc43bf3110">Vector</a> &amp; <a class="el" href="a00010.html">Kalman::EKFilter</a>&lt; T, BEG, OQ, OVR, DBG &gt;::predict           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="a00015.html">Vector</a> &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>u_</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inherited]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns the predicted state vector (<em>a priori</em> state estimate). 
<p>
This function is used to predict a future state. First, it resizes any matrix who needs it. Then, it does a partial time update, in the sense that only <em>x</em> is updated, not P. This also means that only the following virtual functions <em>should be</em> called : <code><a class="el" href="a00010.html#00af959e9f2bb73e4a5ccecafd74617d">makeCommonProcess()</a></code> and <code><a class="el" href="a00010.html#8caf231ab87d59bbc4b28ba840fc54d0">makeProcess()</a></code>. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>u_</em>&nbsp;</td><td>Input vector. Will <b>not</b> be destroyed. Can be empty. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Note:</b></dt><dd>The real <em>x</em> is not modified by this function (this is a <code>const</code> function). Only a copy of <em>x</em> is returned. </dd></dl>
<dl compact><dt><b>Warning:</b></dt><dd>For better efficiency, the prediction is returned by reference. The reference points to an internal member of the filter, which means that a new prediction (and many other functions) will invalidate the contents of this vector. This also means that this vector must be copied (or better yet, swapped) as soon as possible if its data is needed later. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="8e2a9f50c3301dc17bd68c58396369a5"></a><!-- doxytag: member="Kalman::KFilter::simulate" ref="8e2a9f50c3301dc17bd68c58396369a5" args="()" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;typename T, K_UINT_32 BEG, bool OQ, bool OVR, bool DBG&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top">const <a class="el" href="a00010.html">EKFilter</a>&lt; T, BEG, OQ, OVR, DBG &gt;::<a class="el" href="a00010.html#57dea6f5039281b7fee517fc43bf3110">Vector</a> &amp; <a class="el" href="a00010.html">Kalman::EKFilter</a>&lt; T, BEG, OQ, OVR, DBG &gt;::simulate           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inherited]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns the predicted measurement vector. 
<p>
This function is used to predict a future measurement. First, it resizes any matrix who needs it. Then, it does a partial measure update, in the sense that only <em>z</em> is calculated : <em>x</em> and P are not updated. This also means that only the following virtual functions <em>should be</em> called : <code><a class="el" href="a00010.html#b2368423153d84f471a49873224958ab">makeCommonMeasure()</a></code> and <code><a class="el" href="a00010.html#f27fd54297218f5dad3981ea67b0e235">makeMeasure()</a></code>. <dl compact><dt><b>Note:</b></dt><dd>This is a <code>const</code> function. It only works on copies of vectors. </dd></dl>
<dl compact><dt><b>Warning:</b></dt><dd>For better efficiency, the prediction is returned by reference. The reference points to an internal member of the filter, which means that a new prediction (and many other functions) will invalidate the contents of this vector. This also means that this vector must be copied (or better yet, swapped) as soon as possible if its data is needed later. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ac0985755b9fbeb6330aef0c34546a91"></a><!-- doxytag: member="Kalman::KFilter::calculateP" ref="ac0985755b9fbeb6330aef0c34546a91" args="() const " --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;typename T, K_UINT_32 BEG, bool OQ, bool OVR, bool DBG&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top">const <a class="el" href="a00010.html">EKFilter</a>&lt; T, BEG, OQ, OVR, DBG &gt;::<a class="el" href="a00010.html#f53df0293e169f562bc1d9a20e1d2589">Matrix</a> &amp; <a class="el" href="a00010.html">Kalman::EKFilter</a>&lt; T, BEG, OQ, OVR, DBG &gt;::calculateP           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [inherited]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns the <em>a posteriori</em> error covariance estimate matrix. 
<p>
<dl compact><dt><b>Warning:</b></dt><dd>This is not a simple return statement. Since P is not kept and updated in the filter (an alternate and more stable representation of P is used), calculations are involved to retrieve P. So, use this function wisely. <p>
For better efficiency, P is returned by reference. The reference points to an internal member of the filter, which means that other functions may invalidate the contents of this matrix. This also means that this matrix must be copied (or better yet, swapped) as soon as possible if its data is needed later. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="bfca7d629f94d7954e48597108e0ba21"></a><!-- doxytag: member="Kalman::KFilter::NoModification" ref="bfca7d629f94d7954e48597108e0ba21" args="()" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;typename T, K_UINT_32 BEG, bool OQ, bool OVR, bool DBG&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top">void <a class="el" href="a00010.html">Kalman::EKFilter</a>&lt; T, BEG, OQ, OVR, DBG &gt;::NoModification           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [protected, inherited]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Allows optimizations on some calculations. 
<p>
By default, the <a class="el" href="a00010.html">EKFilter</a> template class suppose that matrix pre-creators and creators modify all matrices. However, if it could suppose that some of these functions do not modify anything, some calculations could be optimized away. The <code><a class="el" href="a00010.html#bfca7d629f94d7954e48597108e0ba21">NoModification()</a></code> function says that the function in which it has been called has not modified any matrix. For optimization purposes, this means that this function should be called in every non-mutating execution branch of all <code>make*</code>() and <code>makeBase*</code>() functions.     </td>
  </tr>
</table>
<a class="anchor" name="5df090d462672680b2727f9d777ecf38"></a><!-- doxytag: member="Kalman::KFilter::makeBaseQ" ref="5df090d462672680b2727f9d777ecf38" args="()" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;typename T, K_UINT_32 BEG, bool OQ, bool OVR, bool DBG&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top">void <a class="el" href="a00010.html">Kalman::EKFilter</a>&lt; T, BEG, OQ, OVR, DBG &gt;::makeBaseQ           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [protected, virtual, inherited]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Virtual pre-creator of <em>Q</em>. 
<p>
<dl compact><dt><b>Note:</b></dt><dd>If <code>OQ</code> is <code>true</code>, that is, if <code>Q</code> is always diagonal, then it is not necessary to initialize non-diagonal elements with anything meaningful. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="328205b3d3440b18cdc7701ca961d40d"></a><!-- doxytag: member="Kalman::KFilter::makeBaseV" ref="328205b3d3440b18cdc7701ca961d40d" args="()" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;typename T, K_UINT_32 BEG, bool OQ, bool OVR, bool DBG&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top">void <a class="el" href="a00010.html">Kalman::EKFilter</a>&lt; T, BEG, OQ, OVR, DBG &gt;::makeBaseV           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [protected, virtual, inherited]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Virtual pre-creator of <em>V</em>. 
<p>
<dl compact><dt><b>Note:</b></dt><dd>If <code>OVR</code> is <code>true</code>, that is, if <code>both</code> V and R are always diagonal, then it is not necessary to initialize non-diagonal elements with anything meaningful. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="48cf2273a4cdeee90fedc917a3c509bb"></a><!-- doxytag: member="Kalman::KFilter::makeBaseR" ref="48cf2273a4cdeee90fedc917a3c509bb" args="()" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;typename T, K_UINT_32 BEG, bool OQ, bool OVR, bool DBG&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top">void <a class="el" href="a00010.html">Kalman::EKFilter</a>&lt; T, BEG, OQ, OVR, DBG &gt;::makeBaseR           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [protected, virtual, inherited]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Virtual pre-creator of <em>R</em>. 
<p>
<dl compact><dt><b>Note:</b></dt><dd>If <code>OVR</code> is <code>true</code>, that is, if <code>both</code> V and R are always diagonal, then it is not necessary to initialize non-diagonal elements with anything meaningful. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="00af959e9f2bb73e4a5ccecafd74617d"></a><!-- doxytag: member="Kalman::KFilter::makeCommonProcess" ref="00af959e9f2bb73e4a5ccecafd74617d" args="()" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;typename T, K_UINT_32 BEG, bool OQ, bool OVR, bool DBG&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top">void <a class="el" href="a00010.html">Kalman::EKFilter</a>&lt; T, BEG, OQ, OVR, DBG &gt;::makeCommonProcess           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [protected, virtual, inherited]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Optional function used to precalculate common values for process. 
<p>
If complex calculations are needed for more than one of <code><a class="el" href="a00010.html#fb6168f2a88d8674d1cfa349bd78263b">makeA()</a></code>, <code><a class="el" href="a00010.html#f1741e4ff0f84763d7207d4f418b0efb">makeW()</a></code>, <code><a class="el" href="a00010.html#a0e7ca750254434464c222094dbd14b2">makeQ()</a></code> and <code><a class="el" href="a00010.html#8caf231ab87d59bbc4b28ba840fc54d0">makeProcess()</a></code> functions, then this function can be used to store the results in temporary variables of the derived class. <dl compact><dt><b>Warning:</b></dt><dd>This function must not modify any matrix of the base class. <p>
This function must not be used to store permanent state. In other words, all calculations performed in this function should be temporary. This is because the <code><a class="el" href="a00010.html#fc92e7081f91b62523576c1b3536e4b3">predict()</a></code> function will call this function but has no knowledge of how to undo it. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a0e7ca750254434464c222094dbd14b2"></a><!-- doxytag: member="Kalman::KFilter::makeQ" ref="a0e7ca750254434464c222094dbd14b2" args="()" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;typename T, K_UINT_32 BEG, bool OQ, bool OVR, bool DBG&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top">void <a class="el" href="a00010.html">Kalman::EKFilter</a>&lt; T, BEG, OQ, OVR, DBG &gt;::makeQ           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [protected, virtual, inherited]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Virtual creator of <em>Q</em>. 
<p>
<dl compact><dt><b>Note:</b></dt><dd>If <code>OQ</code> is <code>true</code>, that is, if <code>Q</code> is always diagonal, then it is not necessary to initialize non-diagonal elements with anything meaningful. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="b2368423153d84f471a49873224958ab"></a><!-- doxytag: member="Kalman::KFilter::makeCommonMeasure" ref="b2368423153d84f471a49873224958ab" args="()" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;typename T, K_UINT_32 BEG, bool OQ, bool OVR, bool DBG&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top">void <a class="el" href="a00010.html">Kalman::EKFilter</a>&lt; T, BEG, OQ, OVR, DBG &gt;::makeCommonMeasure           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [protected, virtual, inherited]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Optional function used to precalculate common values for measurement. 
<p>
If complex calculations are needed for more than one of <code><a class="el" href="a00010.html#0d915861910cdc17361f829d486de6a0">makeH()</a></code>, <code><a class="el" href="a00010.html#67f3a2a311f16ab10ce684dacc46b4ce">makeV()</a></code>, <code><a class="el" href="a00010.html#c8ed8c9c7a53f9f4108f64e5710ad926">makeR()</a></code>, <code><a class="el" href="a00010.html#f27fd54297218f5dad3981ea67b0e235">makeMeasure()</a></code> and <code><a class="el" href="a00010.html#df3cc66147296230b4e8da64460426be">makeDZ()</a></code> functions, then this function can be used to store the results in temporary variables of the derived class. <dl compact><dt><b>Warning:</b></dt><dd>This function must not modify any matrix of the base class. <p>
This function must not be used to store permanent state. In other words, all calculations performed in this function should be temporary. This is because the <code><a class="el" href="a00010.html#8e2a9f50c3301dc17bd68c58396369a5">simulate()</a></code> function will call this function but has no knowledge of how to undo it. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="67f3a2a311f16ab10ce684dacc46b4ce"></a><!-- doxytag: member="Kalman::KFilter::makeV" ref="67f3a2a311f16ab10ce684dacc46b4ce" args="()" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;typename T, K_UINT_32 BEG, bool OQ, bool OVR, bool DBG&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top">void <a class="el" href="a00010.html">Kalman::EKFilter</a>&lt; T, BEG, OQ, OVR, DBG &gt;::makeV           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [protected, virtual, inherited]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Virtual creator of <em>V</em>. 
<p>
<dl compact><dt><b>Note:</b></dt><dd>If <code>OVR</code> is <code>true</code>, that is, if <code>both</code> V and R are always diagonal, then it is not necessary to initialize non-diagonal elements with anything meaningful. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="c8ed8c9c7a53f9f4108f64e5710ad926"></a><!-- doxytag: member="Kalman::KFilter::makeR" ref="c8ed8c9c7a53f9f4108f64e5710ad926" args="()" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;typename T, K_UINT_32 BEG, bool OQ, bool OVR, bool DBG&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top">void <a class="el" href="a00010.html">Kalman::EKFilter</a>&lt; T, BEG, OQ, OVR, DBG &gt;::makeR           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [protected, virtual, inherited]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Virtual creator of <em>R</em>. 
<p>
<dl compact><dt><b>Note:</b></dt><dd>If <code>OVR</code> is <code>true</code>, that is, if <code>both</code> V and R are always diagonal, then it is not necessary to initialize non-diagonal elements with anything meaningful. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="df3cc66147296230b4e8da64460426be"></a><!-- doxytag: member="Kalman::KFilter::makeDZ" ref="df3cc66147296230b4e8da64460426be" args="()" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;typename T, K_UINT_32 BEG, bool OQ, bool OVR, bool DBG&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top">void <a class="el" href="a00010.html">Kalman::EKFilter</a>&lt; T, BEG, OQ, OVR, DBG &gt;::makeDZ           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [protected, virtual, inherited]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Hook-up function to modify innovation vector. 
<p>
This function should rarely be overridden ; this is more of a hack than anything else. In fact, this is used to perform adjustements on the result of substracting the predicted measurement vector to the real measurement vector. This is needed, for example, when measures include angles. It may be mandatory that the difference of the two angles be in a certain range, like <img class="formulaInl" alt="$ [-\pi, \pi] $" src="form_53.png"> .     </td>
  </tr>
</table>
<hr><h2>Member Data Documentation</h2>
<a class="anchor" name="9dd4e461268c8034f5c8564e155c67a6"></a><!-- doxytag: member="Kalman::KFilter::x" ref="9dd4e461268c8034f5c8564e155c67a6" args="" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;typename T, K_UINT_32 BEG, bool OQ = false, bool OVR = false, bool DBG = true&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="a00010.html#57dea6f5039281b7fee517fc43bf3110">Vector</a> <a class="el" href="a00010.html">Kalman::EKFilter</a>&lt; T, BEG, OQ, OVR, DBG &gt;::<a class="el" href="a00010.html#9dd4e461268c8034f5c8564e155c67a6">x</a><code> [protected, inherited]</code>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Corrected state vector. 
<p>
This is an <em>n-sized</em> vector. Derived classes should modify it only through <code><a class="el" href="a00010.html#8caf231ab87d59bbc4b28ba840fc54d0">makeProcess()</a></code>.     </td>
  </tr>
</table>
<a class="anchor" name="7b774effe4a349c6dd82ad4f4f21d34c"></a><!-- doxytag: member="Kalman::KFilter::u" ref="7b774effe4a349c6dd82ad4f4f21d34c" args="" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;typename T, K_UINT_32 BEG, bool OQ = false, bool OVR = false, bool DBG = true&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="a00010.html#57dea6f5039281b7fee517fc43bf3110">Vector</a> <a class="el" href="a00010.html">Kalman::EKFilter</a>&lt; T, BEG, OQ, OVR, DBG &gt;::<a class="el" href="a00010.html#7b774effe4a349c6dd82ad4f4f21d34c">u</a><code> [protected, inherited]</code>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Input vector. 
<p>
This is an <em>nu-sized</em> vector. Derived classes should never modify it.     </td>
  </tr>
</table>
<a class="anchor" name="fbade9e36a3f36d3d676c1b808451dd7"></a><!-- doxytag: member="Kalman::KFilter::z" ref="fbade9e36a3f36d3d676c1b808451dd7" args="" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;typename T, K_UINT_32 BEG, bool OQ = false, bool OVR = false, bool DBG = true&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="a00010.html#57dea6f5039281b7fee517fc43bf3110">Vector</a> <a class="el" href="a00010.html">Kalman::EKFilter</a>&lt; T, BEG, OQ, OVR, DBG &gt;::<a class="el" href="a00010.html#fbade9e36a3f36d3d676c1b808451dd7">z</a><code> [protected, inherited]</code>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Predicted measurement vector. 
<p>
This is an <em>m-sized</em> vector. Derived classes should modify it only through <code><a class="el" href="a00010.html#f27fd54297218f5dad3981ea67b0e235">makeMeasure()</a></code>.     </td>
  </tr>
</table>
<a class="anchor" name="0de7b6a61a70688b26e6eeb3113531a3"></a><!-- doxytag: member="Kalman::KFilter::dz" ref="0de7b6a61a70688b26e6eeb3113531a3" args="" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;typename T, K_UINT_32 BEG, bool OQ = false, bool OVR = false, bool DBG = true&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="a00010.html#57dea6f5039281b7fee517fc43bf3110">Vector</a> <a class="el" href="a00010.html">Kalman::EKFilter</a>&lt; T, BEG, OQ, OVR, DBG &gt;::<a class="el" href="a00010.html#0de7b6a61a70688b26e6eeb3113531a3">dz</a><code> [protected, inherited]</code>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Innovation vector. 
<p>
This is an <em>m-sized</em> vector. Derived classes should modify it only through <code><a class="el" href="a00010.html#df3cc66147296230b4e8da64460426be">makeDZ()</a></code>. The innovation vector is the difference between the real measurement vector and the predicted one.     </td>
  </tr>
</table>
<a class="anchor" name="7fc56270e7a70fa81a5935b72eacbe29"></a><!-- doxytag: member="Kalman::KFilter::A" ref="7fc56270e7a70fa81a5935b72eacbe29" args="" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;typename T, K_UINT_32 BEG, bool OQ = false, bool OVR = false, bool DBG = true&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="a00010.html#f53df0293e169f562bc1d9a20e1d2589">Matrix</a> <a class="el" href="a00010.html">Kalman::EKFilter</a>&lt; T, BEG, OQ, OVR, DBG &gt;::<a class="el" href="a00010.html#7fc56270e7a70fa81a5935b72eacbe29">A</a><code> [protected, inherited]</code>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
A jacobian matrix. 
<p>
This is an <em>n</em> by <em>n</em> jacobian matrix of partial derivatives, defined as follow : <p class="formulaDsp">
<img class="formulaDsp" alt="\[ A_{[i,j]} = \frac{\partial f_{[i]}}{\partial x_{[j]}} \]" src="form_21.png">
<p>
 Derived classes should modify it only through <code><a class="el" href="a00010.html#518036f135c91caa3c3d76b172775485">makeBaseA()</a></code> for the constant part and <code><a class="el" href="a00010.html#fb6168f2a88d8674d1cfa349bd78263b">makeA()</a></code> for the variable part.     </td>
  </tr>
</table>
<a class="anchor" name="61e9c06ea9a85a5088a499df6458d276"></a><!-- doxytag: member="Kalman::KFilter::W" ref="61e9c06ea9a85a5088a499df6458d276" args="" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;typename T, K_UINT_32 BEG, bool OQ = false, bool OVR = false, bool DBG = true&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="a00010.html#f53df0293e169f562bc1d9a20e1d2589">Matrix</a> <a class="el" href="a00010.html">Kalman::EKFilter</a>&lt; T, BEG, OQ, OVR, DBG &gt;::<a class="el" href="a00010.html#61e9c06ea9a85a5088a499df6458d276">W</a><code> [protected, inherited]</code>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
A jacobian matrix. 
<p>
This is an <em>n</em> by <em>nw</em> jacobian matrix of partial derivatives, defined as follow : <p class="formulaDsp">
<img class="formulaDsp" alt="\[ W_{[i,j]} = \frac{\partial f_{[i]}}{\partial w_{[j]}} \]" src="form_22.png">
<p>
 Derived classes should modify it only through <code><a class="el" href="a00010.html#fee4e2d5e2ee0e0b384328ef4b5acd10">makeBaseW()</a></code> for the constant part and <code><a class="el" href="a00010.html#f1741e4ff0f84763d7207d4f418b0efb">makeW()</a></code> for the variable part.     </td>
  </tr>
</table>
<a class="anchor" name="f09564c9ca56850d4cd6b3319e541aee"></a><!-- doxytag: member="Kalman::KFilter::Q" ref="f09564c9ca56850d4cd6b3319e541aee" args="" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;typename T, K_UINT_32 BEG, bool OQ = false, bool OVR = false, bool DBG = true&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="a00010.html#f53df0293e169f562bc1d9a20e1d2589">Matrix</a> <a class="el" href="a00010.html">Kalman::EKFilter</a>&lt; T, BEG, OQ, OVR, DBG &gt;::<a class="el" href="a00010.html#f09564c9ca56850d4cd6b3319e541aee">Q</a><code> [protected, inherited]</code>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Process noise covariance matrix. 
<p>
This is the <em>nw</em> by <em>nw</em> covariance matrix of <em>w</em>, that is : <p class="formulaDsp">
<img class="formulaDsp" alt="\[ Q = E\left( w w^T \right) \]" src="form_54.png">
<p>
 Derived classes should modify it only through <code><a class="el" href="a00010.html#5df090d462672680b2727f9d777ecf38">makeBaseQ()</a></code> for the constant part and <code><a class="el" href="a00010.html#a0e7ca750254434464c222094dbd14b2">makeQ()</a></code> for the variable part. If <em>Q</em> is always diagonal, then you should turn on the <code>OQ</code> optimization.     </td>
  </tr>
</table>
<a class="anchor" name="c1d9f50f86825a1a2302ec2449c17196"></a><!-- doxytag: member="Kalman::KFilter::H" ref="c1d9f50f86825a1a2302ec2449c17196" args="" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;typename T, K_UINT_32 BEG, bool OQ = false, bool OVR = false, bool DBG = true&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="a00010.html#f53df0293e169f562bc1d9a20e1d2589">Matrix</a> <a class="el" href="a00010.html">Kalman::EKFilter</a>&lt; T, BEG, OQ, OVR, DBG &gt;::<a class="el" href="a00010.html#c1d9f50f86825a1a2302ec2449c17196">H</a><code> [protected, inherited]</code>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
A jacobian matrix. 
<p>
This is an <em>m</em> by <em>n</em> jacobian matrix of partial derivatives, defined as follow : <p class="formulaDsp">
<img class="formulaDsp" alt="\[ H_{[i,j]} = \frac{\partial h_{[i]}}{\partial x_{[j]}} \]" src="form_23.png">
<p>
 Derived classes should modify it only through <code><a class="el" href="a00010.html#82beae7bd03ecf043dc2879020211a01">makeBaseH()</a></code> for the constant part and <code><a class="el" href="a00010.html#0d915861910cdc17361f829d486de6a0">makeH()</a></code> for the variable part.     </td>
  </tr>
</table>
<a class="anchor" name="5206560a306a2e085a437fd258eb57ce"></a><!-- doxytag: member="Kalman::KFilter::V" ref="5206560a306a2e085a437fd258eb57ce" args="" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;typename T, K_UINT_32 BEG, bool OQ = false, bool OVR = false, bool DBG = true&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="a00010.html#f53df0293e169f562bc1d9a20e1d2589">Matrix</a> <a class="el" href="a00010.html">Kalman::EKFilter</a>&lt; T, BEG, OQ, OVR, DBG &gt;::<a class="el" href="a00010.html#5206560a306a2e085a437fd258eb57ce">V</a><code> [protected, inherited]</code>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
A jacobian matrix. 
<p>
This is an <em>m</em> by <em>nv</em> jacobian matrix of partial derivatives, defined as follow : <p class="formulaDsp">
<img class="formulaDsp" alt="\[ V_{[i,j]} = \frac{\partial h_{[i]}}{\partial v_{[j]}} \]" src="form_24.png">
<p>
 Derived classes should modify it only through <code><a class="el" href="a00010.html#328205b3d3440b18cdc7701ca961d40d">makeBaseV()</a></code> for the constant part and <code><a class="el" href="a00010.html#67f3a2a311f16ab10ce684dacc46b4ce">makeV()</a></code> for the variable part. If both V and R are always diagonal, then you should turn on the <code>OVR</code> optimization.     </td>
  </tr>
</table>
<a class="anchor" name="e1e1d3d40573127e9ee0480caf1283d6"></a><!-- doxytag: member="Kalman::KFilter::R" ref="e1e1d3d40573127e9ee0480caf1283d6" args="" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;typename T, K_UINT_32 BEG, bool OQ = false, bool OVR = false, bool DBG = true&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="a00010.html#f53df0293e169f562bc1d9a20e1d2589">Matrix</a> <a class="el" href="a00010.html">Kalman::EKFilter</a>&lt; T, BEG, OQ, OVR, DBG &gt;::<a class="el" href="a00010.html#e1e1d3d40573127e9ee0480caf1283d6">R</a><code> [protected, inherited]</code>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Measurement noise covariance matrix. 
<p>
This is the <em>nv</em> by <em>nv</em> covariance matrix of <em>v</em>, that is : <p class="formulaDsp">
<img class="formulaDsp" alt="\[ R = E\left( v v^T \right) \]" src="form_55.png">
<p>
 Derived classes should modify it only through <code><a class="el" href="a00010.html#48cf2273a4cdeee90fedc917a3c509bb">makeBaseR()</a></code> for the constant part and <code><a class="el" href="a00010.html#c8ed8c9c7a53f9f4108f64e5710ad926">makeR()</a></code> for the variable part. If both <em>V</em> and <em>R</em> are always diagonal, then you should turn on the <code>OVR</code> optimization.     </td>
  </tr>
</table>
<hr>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="a00034.html">kfilter.hpp</a><li><a class="el" href="a00035.html">kfilter_impl.hpp</a></ul>
<hr size="1"><address style="align: right;"><small>Generated on Sat Jan 28 21:02:01 2006 for KFilter by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.5 </small></address>
</body>
</html>
