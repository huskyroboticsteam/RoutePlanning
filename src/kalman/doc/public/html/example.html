<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>KFilter: </title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.5 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li><a href="annotated.html"><span>Classes</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li><a href="dirs.html"><span>Directories</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
  </ul></div>
<a class="anchor" name="expage"></a> <h2><a class="anchor" name="example">
How to Use this Extended Kalman Filter Library?</a></h2>
<h3><a class="anchor" name="introduction">
Introduction</a></h3>
This Extended Kalman Filter library is powerful and very simple to use, but a Kalman filter is very difficult to debug. So, it is very important to follow a procedure to be sure that everything is right (code and equations). This example suggests a procedure to follow and shows how to use the library. If you are not familiar with the Kalman filter, please read this article [02].<h3><a class="anchor" name="step1">
Step 1 : Find the mathematical model of the system</a></h3>
The first thing to do is to find out the state vector you want to estimate <img class="formulaInl" alt="$ \vec x $" src="form_0.png"> and the inputs <img class="formulaInl" alt="$ \vec u $" src="form_1.png"> of the system. After this, find the non-linear process function <img class="formulaInl" alt="$ f $" src="form_2.png"> that describes the evolution of the state vector through time, that is : <p class="formulaDsp">
<img class="formulaDsp" alt="\[ \vec x_k = f \left( x_{k-1}, u_{k-1}, w_{k-1} \right) \]" src="form_3.png">
<p>
 where <img class="formulaInl" alt="$ w $" src="form_4.png"> is the process noise vector due to uncertainty and process modeling errors.<p>
Then, find the non-linear relation between your state vector <img class="formulaInl" alt="$ \vec x $" src="form_0.png"> and the measure vector <img class="formulaInl" alt="$ \vec z $" src="form_5.png"> . <p class="formulaDsp">
<img class="formulaDsp" alt="\[ \vec z_k = h \left( x_{k-1}, v_{k-1} \right) \]" src="form_6.png">
<p>
 where <img class="formulaInl" alt="$ v $" src="form_7.png"> is the measure noise vector.<p>
<dl compact><dt><b>In this example :</b></dt><dd></dd></dl>
A plane flies in a 2D space where the x axis is the distance traveled by the plane and y axis is its altitude. This system can be represented by the following continuous equations:<p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \ddot x = \frac{u}{m} - \frac{b_x}{m} \dot x^{2} \]" src="form_8.png">
<p>
 <p class="formulaDsp">
<img class="formulaDsp" alt="\[ \ddot y = \frac{p}{m} \dot x^{2} - g \]" src="form_9.png">
<p>
<p>
where <img class="formulaInl" alt="$ m $" src="form_10.png"> is the plane's weight (1000 kg)<br>
 <img class="formulaInl" alt="$ b_{x} $" src="form_11.png"> is the drag coefficient (0.35 N/m²/s²)<br>
 <img class="formulaInl" alt="$ p $" src="form_12.png"> is the lift force (3.92 N/m²/s²)<br>
 <img class="formulaInl" alt="$ g $" src="form_13.png"> is the gravitational acceleration (9.8 m/s²)<br>
 <img class="formulaInl" alt="$ u $" src="form_14.png"> (the input) is the motor's thrust<br>
<p>
The discrete equation is: <p class="formulaDsp">
<img class="formulaDsp" alt="\[\vec x_k = \left [ \begin{array}{c} x_k \\ \\ \dot x_k \\ \\ y_k \\ \\ \dot y_k \end{array} \right] = \left [ \begin{array}{c} x_{k-1} + T \dot x_{k-1} + \frac{T^{2}}{2} \left( \frac{u}{m} - \frac{b_x}{m} \dot x_{k-1}^{2} \right )\\ \\ \dot x_{k-1} + T \left ( \frac{u}{m} - \frac{b_x}{m} \dot x_{k-1}^{2} \right ) + w_{1} \\ \\ y_{k-1} + T \dot y_{k-1} + \frac{T^{2}}{2} \left( \frac{p}{m} \dot x_{k-1}^{2} - g \right )\\ \\ \dot y_{k-1} + T \left( \frac{p}{m} \dot x_{k-1}^{2} - g \right ) + w_{2} \end{array} \right ] \]" src="form_15.png">
<p>
<p>
where <img class="formulaInl" alt="$ w_{1} $" src="form_16.png"> and <img class="formulaInl" alt="$ w_{2} $" src="form_17.png"> are the random variables which represent the process noise.<p>
A station on the ground (at the origin) mesures the angle between the plane and the ground (x axis) and the distance between the plane and the station. These measures are based on the following equation:<p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[\vec z_k = \left [ \begin{array}{c} \theta \\ \\ r \end{array} \right ] = \left [ \begin{array}{c} atan(\frac{y}{x}) +v_{1} \\ \\ \sqrt{x^{2}+y^{2}} + v_{2} \end{array} \right ] \]" src="form_18.png">
<p>
<p>
where <img class="formulaInl" alt="$ v_{1} $" src="form_19.png"> and <img class="formulaInl" alt="$ v_{2} $" src="form_20.png"> are the random variables which represent the process noise.<h3><a class="anchor" name="step2">
Step 2 : Calculate Jacobian matrix</a></h3>
Calculate the jacobian matrix A, W, H and V where : A is an <em>n</em> by <em>n</em> jacobian matrix of partial derivatives, defined as follow : <p class="formulaDsp">
<img class="formulaDsp" alt="\[ A_{[i,j]} = \frac{\partial f_{[i]}}{\partial x_{[j]}} \]" src="form_21.png">
<p>
<p>
W is an <em>n</em> by <em>nv</em> jacobian matrix of partial derivatives, defined as follow : <p class="formulaDsp">
<img class="formulaDsp" alt="\[ W_{[i,j]} = \frac{\partial f_{[i]}}{\partial w_{[j]}} \]" src="form_22.png">
<p>
<p>
H is an <em>m</em> by <em>n</em> jacobian matrix of partial derivatives, defined as follow : <p class="formulaDsp">
<img class="formulaDsp" alt="\[ H_{[i,j]} = \frac{\partial h_{[i]}}{\partial x_{[j]}} \]" src="form_23.png">
<p>
<p>
V is an <em>m</em> by <em>nv</em> jacobian matrix of partial derivatives, defined as follow : <p class="formulaDsp">
<img class="formulaDsp" alt="\[ V_{[i,j]} = \frac{\partial h_{[i]}}{\partial v_{[j]}} \]" src="form_24.png">
<p>
<p>
<img class="formulaInl" alt="$ n $" src="form_25.png"> is the number of element in state vector<br>
 <img class="formulaInl" alt="$ m $" src="form_10.png"> is the number of measure<br>
 <img class="formulaInl" alt="$ nw $" src="form_26.png"> is the number of process noise random variables<br>
 <img class="formulaInl" alt="$ nv $" src="form_27.png"> is the number of measure noise random variables<br>
<p>
<dl compact><dt><b>In this example:</b></dt><dd></dd></dl>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ A = \left [ \begin{array}{cccc} 1 &amp; T-T^{2} \frac{b}{m} \dot x_{k-1} &amp; 0 &amp; 0 \\ \\ 0 &amp; 1-2T \frac{b}{m} \dot x_{k-1} &amp; 0 &amp; 0 \\ \\ 0 &amp; T^{2} \frac{p}{m} \dot x_{k-1} &amp; 1 &amp; T \\ \\ 0 &amp; 2T \frac{p}{m} \dot x_{k-1} &amp; 0 &amp; 1 \end{array} \right ] \]" src="form_28.png">
<p>
<p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ W = \left [ \begin{array}{cc} 0 &amp; 0 \\ \\ 1 &amp; 0 \\ \\ 0 &amp; 0\\ \\ 0 &amp; 1 \end{array} \right ] \]" src="form_29.png">
<p>
<p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ H = \left [ \begin{array}{cccc} \frac{- \dot y_{k-1}}{x_{k-1}^{2}+y_{k-1}^{2}} &amp; 0 \frac{ \dot x_{k-1}}{x_{k-1}^{2}+y_{k-1}^{2}} &amp; 0 \\ \\ \frac{ \dot x_{k-1}}{\sqrt{x_{k-1}^{2}+y_{k-1}^{2}}} &amp; 0 \frac{ \dot y_{k-1}}{\sqrt{x_{k-1}^{2}+y_{k-1}^{2}}} &amp; 0 \end{array} \right ] \]" src="form_30.png">
<p>
<p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ V = \left [ \begin{array}{cc} 1 &amp; 0 \\ \\ 0 &amp; 1 \end{array} \right ] \]" src="form_31.png">
<p>
<h3><a class="anchor" name="step3">
Step 3 : Initial conditions and covariance matrix</a></h3>
Set initial estimation of the state vector. After, set the covariance matrix P which represents the covariance of the error of the state vector estimation. Then, set the covariance Q and R which represent the covariance matrix of process noise and measurement noise, respectively.<p>
<dl compact><dt><b>In this example:</b></dt><dd></dd></dl>
The first estimation of the state vector is based on the first measures and the covariance matrix are the following:<p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[\vec x = \left [ \begin{array}{c} r\cos\theta \\ 60 \\ r\sin\theta \\ 0 \end{array} \right] \]" src="form_32.png">
<p>
<p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ P = \left [ \begin{array}{cccc} 100^2 &amp; 0 &amp; 0 &amp; 0 \\ \\ 0 &amp; 10^2 &amp; 0 &amp; 0 \\ \\ 0 &amp; 0 &amp; 25^2 &amp; 0 \\ \\ 0 &amp; 0 &amp; 0 &amp; 10^2 \\ \\ \end{array} \right ] \]" src="form_33.png">
<p>
<p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ Q = \left [ \begin{array}{cc} 0.01^{2} &amp; 0.01^{2}/10 \\ \\ 0.01^{2}/10 &amp; 0.01^{2} \end{array} \right ] \]" src="form_34.png">
<p>
<p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ R = \left [ \begin{array}{cc} 0.01^{2} &amp; 0 \\ \\ 0 &amp; 0.01^{2} \end{array} \right ] \]" src="form_35.png">
<p>
<h3><a class="anchor" name="step4">
Step 4 : Implementation of the Kalman filter</a></h3>
Now, it's time to create the first version of your Kalman filter. You should not try to optimize it at this step, just create your filter and validate it. This library allows you to optimize your filter, but in your first implementation, code only the basic functions. So, code functions called <code>makeProcess()</code>, <code>makeMeasure()</code>, <code>makeA()</code>, <code>makeH()</code>, <code>makeQ()</code>, <code>makeR()</code>, <code>makeV()</code> and <code>makeW()</code>. These functions will set the value of each matrix.<p>
The first thing to do is to create your Kalman filter class.<p>
 <div class="fragment"><pre class="fragment"><span class="keyword">class </span>cPlaneEKF : <span class="keyword">public</span> Kalman::EKFilter&lt;double,1&gt; {
<span class="keyword">public</span>:
        cPlaneEKF();

<span class="keyword">protected</span>:

        <span class="keywordtype">void</span> makeA();
        <span class="keywordtype">void</span> makeH();
        <span class="keywordtype">void</span> makeV();
        <span class="keywordtype">void</span> makeR();
        <span class="keywordtype">void</span> makeW();
        <span class="keywordtype">void</span> makeQ();
        <span class="keywordtype">void</span> makeProcess();
        <span class="keywordtype">void</span> makeMeasure();

        <span class="keywordtype">double</span> Period, Mass, Bfriction, Portance, Gravity;
};
</pre></div><p>
In this example, our Kalman filter inherits from the Extended Kalman Filter, because it's a non-linear problem (<img class="formulaInl" alt="$ f $" src="form_2.png"> and <img class="formulaInl" alt="$ h $" src="form_36.png"> are non-linear functions) The first two template parameters are respectively the floating point type used by the filter (<code>float</code> or <code>double</code>) and the beginning index of vectors and matrices (0 or 1). There are three other template parameters to the <code>EKFilter</code> template class. They are explained in the next section, but they can be safely set to their default values in the first version of the filter, which are false, false and true to disable optimizations and enable bound-checking.<p>
You should declare each functions named previously in this class. You can declare variables too.<p>
After, code the class constructor. You can call the function <code>setDim()</code> here or you will call it manually in your <code>main()</code> function after you created the filter object. The function <code>setDim()</code> sets the number of states, the number of inputs, the number of process noise random variables, the number of measures and the number of measurement noise random variables. It can be used by advanced users to implement a Variable-Dimension Extended Kalman Filter (an EKF whose dimensions may change from one iteration to the other).<p>
 <div class="fragment"><pre class="fragment">cPlaneEKF::cPlaneEKF() 
{
        setDim(4, 1, 2, 2, 2);
        Period = 0.2;
        Gravity = 9.8;
        Bfriction = 0.35;
        Portance = 3.92;
        Mass = 1000;
}
</pre></div><p>
In the function <code>makeProcess()</code>, you should use a temporary vector to store the new state vector like this :<p>
<div class="fragment"><pre class="fragment"><span class="keywordtype">void</span> cPlaneEKF::makeProcess()
{
        Vector x_(x.size());
        x_(1) = x(1) + x(2)*Period + (Period*Period)/2*(u(1)/Mass - Bfriction/Mass*x(2)*x(2));
        x_(2) = x(2) + (u(1)/Mass - Bfriction/Mass*x(2)*x(2))*Period;
        x_(3) = x(3) + x(4)*Period + (Period*Period)/2*(Portance/Mass*x(2)*x(2)-Gravity);
        x_(4) = x(4) + (Portance/Mass*x(2)*x(2)-Gravity)*Period;
        x.swap(x_);
}
</pre></div><p>
In the function <code>makeMeasure()</code>, you update directly the measures vector <img class="formulaInl" alt="$ \vec z $" src="form_5.png"> . These are the predicted measures.<p>
<div class="fragment"><pre class="fragment"><span class="keywordtype">void</span> cPlaneEKF::makeMeasure()
{
        z(1)=atan2(x(3), x(1));
        z(2)=sqrt(x(1)*x(1)+x(3)*x(3));
}
</pre></div><p>
Then, you code all other functions <code>makeX()</code> like this:<p>
 <div class="fragment"><pre class="fragment"><span class="keywordtype">void</span> cPlaneEKF::makeA()
{
        A(1,1) = 1.0;
        A(1,2) = Period - Period*Period*Bfriction/Mass*x(2);
        A(1,3) = 0.0;
        A(1,4) = 0.0;

        A(2,1) = 0.0;
        A(2,2) = 1 - 2*Period*Bfriction/Mass*x(2);
        A(2,3) = 0.0;
        A(2,4) = 0.0;

        A(3,1) = 0.0;
        A(3,2) = Period*Period*Portance/Mass*x(2);
        A(3,3) = 1.0;
        A(3,4) = Period;

        A(4,1) = 0.0;
        A(4,2) = 2*Period*Portance/Mass*x(2);
        A(4,3) = 0.0;
        A(4,4) = 1.0;
}
</pre></div><p>
<div class="fragment"><pre class="fragment"><span class="keywordtype">void</span> cPlaneEKF::makeW()
{
        W(1,1) = 0.0;
        W(1,2) = 0.0;
        W(2,1) = 1.0;
        W(2,2) = 0.0;
        W(3,1) = 0.0;
        W(3,2) = 0.0;
        W(4,1) = 0.0;
        W(4,2) = 1.0;
}
</pre></div><p>
<div class="fragment"><pre class="fragment"><span class="keywordtype">void</span> cPlaneEKF::makeQ()
{
        Q(1,1) = 0.01*0.01;
        Q(1,2) = 0.01*0.01/10.0;
        Q(2,1) = 0.01*0.01/10.0;
        Q(2,2) = 0.01*0.01;
}
</pre></div><p>
<div class="fragment"><pre class="fragment"><span class="keywordtype">void</span> cPlaneEKF::makeH()
{
        H(1,1) = -x(3)/(x(1)*x(1)+x(3)*x(3));
        H(1,2) = 0.0;
        H(1,3) = x(1)/(x(1)*x(1)+x(3)*x(3));
        H(1,4) = 0.0;

        H(2,1) = x(1)/sqrt(x(1)*x(1)+x(3)*x(3));
        H(2,2) = 0.0;
        H(2,3) = x(3)/sqrt(x(1)*x(1)+x(3)*x(3));
        H(2,4) = 0.0;
}
</pre></div><p>
<div class="fragment"><pre class="fragment"><span class="keywordtype">void</span> cPlaneEKF::makeV()
{
        V(1,1) = 1.0;
        V(1,2) = 0.0;
        V(2,1) = 0.0;
        V(2,2) = 1.0;
}
</pre></div><p>
<div class="fragment"><pre class="fragment"><span class="keywordtype">void</span> cPlaneEKF::makeR()
{
        R(1,1) = 0.01*0.01;
        R(1,2) = 0.0;
        R(2,1) = 0.0;
        R(2,2) = 50*50;
}
</pre></div><p>
Now, your filter is ready to be used. In this example, the measures and the inputs have been calculated by the <code>generation.m</code> Matlab script. It's a good idea to test your filter with fixed measures and inputs if you want to validate it.<p>
After you create the filter object, you should call the <code>setDim()</code> function before calling the <code>init()</code> function. In this example, the <code>setDim()</code> function is called in the class constructor. The <code>init()</code> function sets the initial state and the initial covariance matrix.<p>
WARNING : The vectors passed to the <code>init()</code> function become unusable when <code>init()</code> returns ! Never use those vectors after the call.<p>
 <div class="fragment"><pre class="fragment">        cPlaneEKF filter;

        <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">double</span> _P0[] = {100.0*100.0, 0.0, 0.0, 0.0,
                                                                 0.0, 10.0*10.0, 0.0, 0.0,
                                                                 0.0, 0.0, 25.0*25.0, 0.0,
                                                                 0.0, 0.0, 0.0, 10.0*10.0}; 
</pre></div><p>
<div class="fragment"><pre class="fragment">        <span class="comment">//Initiale estimate</span>
        cout&lt;&lt;<span class="stringliteral">"angle: "</span>&lt;&lt;Measure(1,1)&lt;&lt;<span class="stringliteral">"rayon: "</span>&lt;&lt;Measure(2,1)&lt;&lt;endl;
        x(1) = cos(Measure(1,1))*Measure(2,1);
        x(2) = 60;
        x(3) = sin(Measure(1,1))*Measure(2,1);
        x(4) = 0;

        filter.init(x, P0);
</pre></div><p>
<div class="fragment"><pre class="fragment">        <span class="keywordflow">for</span> (i = 2; i &lt;= NTRY; ++i) 
        {
                <span class="comment">// filter</span>
                <span class="keywordflow">for</span>(j = 1; j &lt;= m; j++)
                        z(j) = Measure(j,i);

                Vector u(1, F(i));

                filter.step(u, z);

                cout &lt;&lt; <span class="stringliteral">"xp("</span> &lt;&lt; <span class="stringliteral">":,"</span> &lt;&lt; i&lt;&lt;<span class="stringliteral">") = "</span> &lt;&lt; filter.getX()&lt;&lt;endl;
                dataOutput&lt;&lt;<span class="stringliteral">"trajectory_udu("</span> &lt;&lt; <span class="stringliteral">":,"</span> &lt;&lt; i&lt;&lt;<span class="stringliteral">") = "</span> &lt;&lt; filter.getX()&lt;&lt;endl;
        }
</pre></div><p>
Call the function <code>step()</code> for each iteration and pass the new inputs and the new measures.<h3><a class="anchor" name="step5">
Step 5 : Optimization</a></h3>
When your Kalman filter works properly, you can optimize it in many simple ways.<p>
<ol type=1>
<li>If matrix Q is always diagonal, set the OQ template parameter to <code>true</code>. This will minimize some calculations. Also, you will only need to fill in diagonal elements of Q, since the other values will never be read.</li><li>If both matrices V and R are always diagonal, set the OVR template parameter to <code>true</code>. This will minimize some calculations. Also, you will only need to fill in diagonal elements of V and R, since the other values will never be read.</li><li>If some matrix values are constant, use the <code>makeBaseX()</code> function instead of the <code>makeX()</code> function to fill these values. These functions are called only once at the beginning instead of once per iteration. You can used the <code>makeBaseX()</code> function to set values that never change in a matrix and just set the other values in the <code>makeX()</code> function.</li><li>If complex calculations are needed for more than one of <code>makeA()</code>, <code>makeW()</code>, <code>makeQ()</code> and <code>makeProcess()</code> functions, then use the function <code>makeCommonProcess()</code> to do those calculations and save them in member variables of your own subclass. This function is always called before the others.</li><li>If complex calculations are needed for more than one of <code>makeH()</code>, <code>makeV()</code>, <code>makeR()</code>, <code>makeMeasure()</code> and <code>makeDZ()</code> functions, then use the function <code>makeCommonMeasure()</code> to do those calculations and save them in member variables of your own subclass. This function is always called before the others.</li><li>While writing a <code>makeX()</code> or a <code>makeBaseX()</code> function, there can be some execution paths where the function does not modify any matrix (for example, if there is some condition, then modify the matrix, else don't). If this is the case, then each non-mutating execution path should call <code>NoModification()</code> before returning, so that some calculations can be avoided.</li><li>When your filter works properly, set the debug template parameter to <code>false</code> to disable bound-checking.</li></ol>
<p>
<dl compact><dt><b>In this example:</b></dt><dd></dd></dl>
This example have been optimized in many ways:<p>
<ul>
<li>The matrices V and R are diagonal, so the OVR template parameter is set to true. Then, we just have to set the diagonal values of those matrices.</li><li>The matrices V, R, W and Q never change, so we use <code>makeBaseX()</code> functions instead of <code>makeX()</code> functions.</li><li>Constants values of A and H have been moved from the <code>makeX()</code> functions to <code>makeBaseX()</code> functions.</li><li>The filter works properly, so we don't need bound-checking. Let's set the debug template parameter to <code>false</code>.</li></ul>
<p>
So, the final result for this example is:<p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#ifndef PLANE_H</span>
<span class="preprocessor"></span><span class="preprocessor">#define PLANE_H</span>
<span class="preprocessor"></span>
<span class="preprocessor">#include "<a class="code" href="a00018.html">kalman/ekfilter.hpp</a>"</span>


<span class="keyword">class </span>cPlaneEKF : <span class="keyword">public</span> Kalman::EKFilter&lt;double,1,false,true,false&gt; {
<span class="keyword">public</span>:
        cPlaneEKF();

<span class="keyword">protected</span>:
        <span class="keywordtype">void</span> makeBaseA();
        <span class="keywordtype">void</span> makeBaseH();
        <span class="keywordtype">void</span> makeBaseV();
        <span class="keywordtype">void</span> makeBaseR();
        <span class="keywordtype">void</span> makeBaseW();
        <span class="keywordtype">void</span> makeBaseQ();

        <span class="keywordtype">void</span> makeA();
        <span class="keywordtype">void</span> makeH();
        <span class="keywordtype">void</span> makeProcess();
        <span class="keywordtype">void</span> makeMeasure();

        <span class="keywordtype">double</span> Period, Mass, Bfriction, Portance, Gravity;
};

<span class="keyword">typedef</span> cPlaneEKF::Vector Vector;
<span class="keyword">typedef</span> cPlaneEKF::Matrix Matrix;

<span class="preprocessor">#endif</span>
</pre></div><p>
<div class="fragment"><pre class="fragment"><span class="comment">// -------------- plane.cpp - Example of Extended Kalman filter ------------------------//</span>
<span class="comment">//</span>
<span class="comment">// This file is part of kfilter.</span>
<span class="comment">// kfilter is a C++ variable-dimension extended kalman filter library.</span>
<span class="comment">//</span>
<span class="comment">// Copyright (C) 2004        Vincent Zalzal, Sylvain Marleau</span>
<span class="comment">// Copyright (C) 2001, 2004  Richard Gourdeau</span>
<span class="comment">// Copyright (C) 2004        GRPR and DGE's Automation sector</span>
<span class="comment">//                           École Polytechnique de Montréal</span>
<span class="comment">//</span>
<span class="comment">// Code adapted from algorithms presented in :</span>
<span class="comment">//      Bierman, G. J. "Factorization Methods for Discrete Sequential</span>
<span class="comment">//      Estimation", Academic Press, 1977.</span>
<span class="comment">//</span>
<span class="comment">// This library is free software; you can redistribute it and/or</span>
<span class="comment">// modify it under the terms of the GNU Lesser General Public</span>
<span class="comment">// License as published by the Free Software Foundation; either</span>
<span class="comment">// version 2.1 of the License, or (at your option) any later version.</span>
<span class="comment">//</span>
<span class="comment">// This library is distributed in the hope that it will be useful,</span>
<span class="comment">// but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="comment">// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</span>
<span class="comment">// Lesser General Public License for more details.</span>
<span class="comment">//</span>
<span class="comment">// You should have received a copy of the GNU Lesser General Public</span>
<span class="comment">// License along with this library; if not, write to the Free Software</span>
<span class="comment">// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA</span>

<span class="comment">// --------------------------- Example of Extended Kalman filter ------------------------//</span>
<span class="comment">/*</span>
<span class="comment">% A plane flights in a 2D space where the x axis is the distance traveled</span>
<span class="comment">% by the plane and y axis is its altitude.  This system can be represented</span>
<span class="comment">% by the fallowing equations:</span>
<span class="comment">% (This is just an example)</span>
<span class="comment">%</span>
<span class="comment">% xpp = F/m - bx/m * xp^2</span>
<span class="comment">% ypp = p/m * xp^2 - g</span>
<span class="comment">%</span>
<span class="comment">% where m is the plane's weight (1000 kg)</span>
<span class="comment">%       bx is the drag coefficient (0.35 N/m²/s²)</span>
<span class="comment">%       p is the lift force (3.92 N/m²/s²)</span>
<span class="comment">%       g is the gravitational acceleration (9.8 m/s²)</span>
<span class="comment">%       F is the motor's thrust</span>
<span class="comment">%</span>
<span class="comment">% A station on the ground (at the origin) mesures the angle between the</span>
<span class="comment">% plane and the ground (x axis) and the distance between the plane and the station.</span>
<span class="comment">% These measures are based and the fallowing equations:</span>
<span class="comment">%</span>
<span class="comment">% theta = atan2(y,x)</span>
<span class="comment">% r = sqrt(x^2+y^2)</span>
<span class="comment">%</span>
<span class="comment">% The variance error matrix of the mesures is:</span>
<span class="comment">%</span>
<span class="comment">% R = [0.01^2  0</span>
<span class="comment">%      0       50^2]</span>
<span class="comment">%</span>
<span class="comment">% V = [1 0;</span>
<span class="comment">%      0 1];</span>
<span class="comment">%</span>
<span class="comment">% The variance error matrix of the plane's model is: WQW'</span>
<span class="comment">%</span>
<span class="comment">% Q = [0.01^2    0;</span>
<span class="comment">%      0         0.01^2];</span>
<span class="comment">%</span>
<span class="comment">% W = [0 0;</span>
<span class="comment">%      1 0;</span>
<span class="comment">%      0 0;</span>
<span class="comment">%      0 1];</span>
<span class="comment">%</span>
<span class="comment">*/</span>

<span class="preprocessor">#include "plane.h"</span>
<span class="preprocessor">#include &lt;cmath&gt;</span>
<span class="preprocessor">#include &lt;iostream&gt;</span>

<span class="keyword">using namespace </span>std;

cPlaneEKF::cPlaneEKF() 
{
        setDim(4, 1, 2, 2, 2);
        Period = 0.2;
        Gravity = 9.8;
        Bfriction = 0.35;
        Portance = 3.92;
        Mass = 1000;
}

<span class="keywordtype">void</span> cPlaneEKF::makeBaseA()
{
        A(1,1) = 1.0;
        <span class="comment">// A(1,2) = Period - Period*Period*Bfriction/Mass*x(2);</span>
        A(1,3) = 0.0;
        A(1,4) = 0.0;

        A(2,1) = 0.0;
        <span class="comment">// A(2,2) = 1 - 2*Period*Bfriction/Mass*x(2);</span>
        A(2,3) = 0.0;
        A(2,4) = 0.0;

        A(3,1) = 0.0;
        <span class="comment">// A(3,2) = Period*Period*Portance/Mass*x(2);</span>
        A(3,3) = 1.0;
        A(3,4) = Period;

        A(4,1) = 0.0;
        <span class="comment">// A(4,2) = 2*Period*Portance/Mass*x(2);</span>
        A(4,3) = 0.0;
        A(4,4) = 1.0;
}

<span class="keywordtype">void</span> cPlaneEKF::makeA()
{
        <span class="comment">// A(1,1) = 1.0;</span>
        A(1,2) = Period - Period*Period*Bfriction/Mass*x(2);
        <span class="comment">// A(1,3) = 0.0;</span>
        <span class="comment">// A(1,4) = 0.0;</span>

        <span class="comment">// A(2,1) = 0.0;</span>
        A(2,2) = 1 - 2*Period*Bfriction/Mass*x(2);
        <span class="comment">// A(2,3) = 0.0;</span>
        <span class="comment">// A(2,4) = 0.0;</span>

        <span class="comment">// A(3,1) = 0.0;</span>
        A(3,2) = Period*Period*Portance/Mass*x(2);
        <span class="comment">// A(3,3) = 1.0;</span>
        <span class="comment">// A(3,4) = Period;</span>

        <span class="comment">// A(4,1) = 0.0;</span>
        A(4,2) = 2*Period*Portance/Mass*x(2);
        <span class="comment">// A(4,3) = 0.0;</span>
        <span class="comment">// A(4,4) = 1.0;</span>
}

<span class="keywordtype">void</span> cPlaneEKF::makeBaseW()
{
        W(1,1) = 0.0;
        W(1,2) = 0.0;
        W(2,1) = 1.0;
        W(2,2) = 0.0;
        W(3,1) = 0.0;
        W(3,2) = 0.0;
        W(4,1) = 0.0;
        W(4,2) = 1.0;
}

<span class="keywordtype">void</span> cPlaneEKF::makeBaseQ()
{
        Q(1,1) = 0.01*0.01;
        Q(1,2) = 0.01*0.01/10.0;
        Q(2,1) = 0.01*0.01/10.0;
        Q(2,2) = 0.01*0.01;
}

<span class="keywordtype">void</span> cPlaneEKF::makeBaseH()
{
        <span class="comment">// H(1,1) = -x(3)/(x(1)*x(1)+x(3)*x(3));</span>
        H(1,2) = 0.0;
        <span class="comment">// H(1,3) = x(1)/(x(1)*x(1)+x(3)*x(3));</span>
        H(1,4) = 0.0;

        <span class="comment">// H(2,1) = x(1)/sqrt(x(1)*x(1)+x(3)*x(3));</span>
        H(2,2) = 0.0;
        <span class="comment">// H(2,3) = x(3)/sqrt(x(1)*x(1)+x(3)*x(3));</span>
        H(2,4) = 0.0;
}

<span class="keywordtype">void</span> cPlaneEKF::makeH()
{
        H(1,1) = -x(3)/(x(1)*x(1)+x(3)*x(3));
        <span class="comment">// H(1,2) = 0.0;</span>
        H(1,3) = x(1)/(x(1)*x(1)+x(3)*x(3));
        <span class="comment">// H(1,4) = 0.0;</span>

        H(2,1) = x(1)/sqrt(x(1)*x(1)+x(3)*x(3));
        <span class="comment">// H(2,2) = 0.0;</span>
        H(2,3) = x(3)/sqrt(x(1)*x(1)+x(3)*x(3));
        <span class="comment">// H(2,4) = 0.0;</span>
}

<span class="keywordtype">void</span> cPlaneEKF::makeBaseV()
{
        V(1,1) = 1.0;
        V(2,2) = 1.0;
}

<span class="keywordtype">void</span> cPlaneEKF::makeBaseR()
{
        R(1,1) = 0.01*0.01;
        R(2,2) = 50*50;
}

<span class="keywordtype">void</span> cPlaneEKF::makeProcess()
{
        Vector x_(x.size());
        x_(1) = x(1) + x(2)*Period + (Period*Period)/2*(u(1)/Mass - Bfriction/Mass*x(2)*x(2));
        x_(2) = x(2) + (u(1)/Mass - Bfriction/Mass*x(2)*x(2))*Period;
        x_(3) = x(3) + x(4)*Period + (Period*Period)/2*(Portance/Mass*x(2)*x(2)-Gravity);
        x_(4) = x(4) + (Portance/Mass*x(2)*x(2)-Gravity)*Period;
        x.swap(x_);
}

<span class="keywordtype">void</span> cPlaneEKF::makeMeasure()
{
        z(1)=atan2(x(3), x(1));
        z(2)=sqrt(x(1)*x(1)+x(3)*x(3));
}

</pre></div><h2><a class="anchor" name="reference">
References</a></h2>
[01] Bierman, G. J. "Factorization Methods for Discrete Sequential Estimation", Academic Press, 1977. <br>
 [02] Welch, G. and Bishop, G. "An Introduction to the %Kalman Filter", <a href="http://www.cs.unc.edu/~welch/kalman/kalmanIntro.html">http://www.cs.unc.edu/~welch/kalman/kalmanIntro.html</a> <hr size="1"><address style="align: right;"><small>Generated on Sat Jan 28 21:02:01 2006 for KFilter by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.5 </small></address>
</body>
</html>
